<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PDM & WAV Signal Processing Toolbox</title>
    <!-- Load Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Custom font and base styling */
        body {
            font-family: 'Inter', sans-serif;
            background-color: #111827; /* Dark background */
        }
        /* Custom scrollbar for better visual on dark mode */
        ::-webkit-scrollbar {
            width: 8px;
        }
        ::-webkit-scrollbar-thumb {
            background: #4b5563;
            border-radius: 4px;
        }
        .section-card {
            background-color: #1f2937;
            border: 1px solid #374151;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }
    </style>
</head>
<body class="p-4 md:p-8 min-h-screen text-gray-100" onload="toggleSignalInputs()">

    <div class="w-full max-w-6xl mx-auto space-y-8">
        <h1 class="text-4xl font-extrabold text-indigo-400 mb-6 text-center">
            PDM & WAV Signal Processing Toolbox
        </h1>
        <p id="status-message" class="text-center text-lg font-medium h-6"></p>

        <!-- Main Grid Layout: 3 columns -->
        <div class="grid grid-cols-1 lg:grid-cols-3 gap-6">

            <!-- 1. PDM Signal Generation (Synthetic and Mic) -->
            <div class="section-card rounded-xl p-6 space-y-4">
                <h2 class="text-2xl font-bold text-indigo-300 border-b border-indigo-500/50 pb-2 mb-4">
                    1. Generate PDM Binary
                </h2>
                <div class="space-y-3">
                    <label for="signalType" class="block text-sm font-medium text-gray-300">Signal Source</label>
                    <select id="signalType" onchange="toggleSignalInputs()" class="w-full p-2 rounded-lg bg-gray-700 border border-gray-600 text-white focus:ring-indigo-500 focus:border-indigo-500">
                        <option value="sine">Synthetic: Sine Wave</option>
                        <option value="square">Synthetic: Square Wave</option>
                        <option value="noise">Synthetic: White Noise</option>
                        <option value="mic">Real-Time: Microphone Input</option>
                    </select>
                </div>

                <!-- SYNTHETIC PARAMETERS -->
                <div id="synthParams" class="space-y-3">
                    <label for="signalFreq" class="block text-sm font-medium text-gray-300">Signal Frequency (Hz)</label>
                    <input type="number" id="signalFreq" value="1000" min="1" class="w-full p-2 rounded-lg bg-gray-700 border border-gray-600 text-white focus:ring-indigo-500 focus:border-indigo-500">

                    <label for="pdmRate" class="block text-sm font-medium text-gray-300">PDM Sample Rate (Hz)</label>
                    <input type="number" id="pdmRate" value="3076864" min="100000" class="w-full p-2 rounded-lg bg-gray-700 border border-gray-600 text-white focus:ring-indigo-500 focus:border-indigo-500">
                </div>

                <!-- MIC PARAMETERS (Conditional Display) -->
                <div id="micParams" class="space-y-3 hidden">
                    <label for="micOsr" class="block text-sm font-medium text-gray-300">Oversampling Ratio (OSR)</label>
                    <!-- Added oninput for dynamic PDM rate calculation -->
                    <input type="number" id="micOsr" value="64" min="2" step="2" oninput="updateMicRates()" class="w-full p-2 rounded-lg bg-gray-700 border border-gray-600 text-white focus:ring-indigo-500 focus:border-indigo-500">
                    <p class="text-xs text-gray-400">PDM Rate = Mic Rate * OSR</p>

                    <!-- DISPLAY AREA FOR MIC PROPERTIES -->
                    <div id="micProperties" class="mt-4 p-3 rounded-lg bg-gray-800 text-sm border border-indigo-600/50">
                        <p><strong>Base Sample Rate:</strong> <span id="micBaseRate">N/A</span> Hz</p>
                        <p><strong>Calculated PDM Rate:</strong> <span id="micCalculatedPdmRate">N/A</span> Hz</p>
                        <!-- NEW LINE FOR CHANNEL INFO -->
                        <p><strong>Input Channels:</strong> <span id="micChannels">N/A</span></p> 
                        <p class="text-xs text-gray-400 mt-1">Rates update on OSR change or Mic selection.</p>
                    </div>
                </div>

                <div class="space-y-3">
                    <label for="duration" class="block text-sm font-medium text-gray-300">Duration (seconds)</label>
                    <input type="number" id="duration" value="1.0" min="0.1" step="0.1" class="w-full p-2 rounded-lg bg-gray-700 border border-gray-600 text-white focus:ring-indigo-500 focus:border-indigo-500">
                </div>
                <button id="generatePdmButton" onclick="handleGeneratePDM()" class="w-full mt-4 bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-3 px-4 rounded-lg transition-all duration-200 focus:outline-none focus:ring-4 focus:ring-indigo-500/50 shadow-md">
                    Generate & Download PDM (.bin)
                </button>
            </div>

            <!-- 2. PDM to WAV Conversion -->
            <div class="section-card rounded-xl p-6 space-y-4">
                <h2 class="text-2xl font-bold text-indigo-300 border-b border-indigo-500/50 pb-2 mb-4">
                    2. PDM Binary to WAV
                </h2>
                <div class="space-y-3">
                    <label for="pdmFile" class="block text-sm font-medium text-gray-300">Upload PDM Binary (.bin)</label>
                    <input type="file" id="pdmFile" accept=".bin, .pdm, application/octet-stream" class="w-full p-2 rounded-lg bg-gray-700 border border-gray-600 text-white focus:ring-indigo-500 focus:border-indigo-500">
                </div>
                <div class="space-y-3">
                    <label for="decimationFactor" class="block text-sm font-medium text-gray-300">Decimation Factor (R)</label>
                    <input type="number" id="decimationFactor" value="64" min="2" step="2" class="w-full p-2 rounded-lg bg-gray-700 border border-gray-600 text-white focus:ring-indigo-500 focus:border-indigo-500">
                    <p class="text-xs text-gray-400">PCM Rate = PDM Rate / R</p>
                </div>
                <div class="space-y-3">
                    <label for="inputPdmRate" class="block text-sm font-medium text-gray-300">Input PDM Rate (Hz)</label>
                    <input type="number" id="inputPdmRate" value="3076864" min="100000" class="w-full p-2 rounded-lg bg-gray-700 border border-gray-600 text-white focus:ring-indigo-500 focus:border-indigo-500">
                </div>
                <!-- BIT DEPTH SELECTION -->
                <div class="space-y-3">
                    <label for="outputBitDepth" class="block text-sm font-medium text-gray-300">PCM Output Bit Depth</label>
                    <select id="outputBitDepth" class="w-full p-2 rounded-lg bg-gray-700 border border-gray-600 text-white focus:ring-indigo-500 focus:border-indigo-500">
                        <option value="16" selected>16-bit Signed Integer (PCM)</option>
                        <option value="24">24-bit Signed Integer (PCM)</option>
                        <option value="8">8-bit Unsigned Integer (PCM)</option>
                        <option value="32f">32-bit Floating Point (IEEE Float)</option>
                    </select>
                </div>
                <button onclick="handlePdmToWav()" class="w-full mt-4 bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-3 px-4 rounded-lg transition-all duration-200 focus:outline-none focus:ring-4 focus:ring-indigo-500/50 shadow-md">
                    Convert & Download WAV
                </button>
            </div>

            <!-- 3. WAV to PDM Conversion -->
            <div class="section-card rounded-xl p-6 space-y-4">
                <h2 class="text-2xl font-bold text-indigo-300 border-b border-indigo-500/50 pb-2 mb-4">
                    3. WAV (PCM) to PDM
                </h2>
                <div class="space-y-3">
                    <label for="wavFile" class="block text-sm font-medium text-gray-300">Upload WAV File (.wav)</label>
                    <input type="file" id="wavFile" accept=".wav, audio/wav" class="w-full p-2 rounded-lg bg-gray-700 border border-gray-600 text-white focus:ring-indigo-500 focus:border-indigo-500">
                </div>
                <div class="space-y-3">
                    <label for="osr" class="block text-sm font-medium text-gray-300">Oversampling Ratio (OSR)</label>
                    <input type="number" id="osr" value="64" min="2" step="2" class="w-full p-2 rounded-lg bg-gray-700 border border-gray-600 text-white focus:ring-indigo-500 focus:border-indigo-500">
                    <p class="text-xs text-gray-400">PDM Rate = WAV Rate * OSR</p>
                </div>
                <button onclick="handleWavToPdm()" class="w-full mt-4 bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-3 px-4 rounded-lg transition-all duration-200 focus:outline-none focus:ring-4 focus:ring-indigo-500/50 shadow-md">
                    Convert & Download PDM (.bin)
                </button>
            </div>

        </div>

    </div>

    <!-- JavaScript Implementation -->
    <script>
        const statusMessage = document.getElementById('status-message');

        // Global variables to cache microphone properties
        let micBaseRate = 0;
        let micChannelCount = 0; // Cache channel count

        /**
         * Generic file downloader function.
         */
        function downloadFile(data, filename, mimeType) {
            const blob = new Blob([data], { type: mimeType });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        /**
         * Sets the application status message.
         */
        function setStatus(message, isError = false) {
            statusMessage.textContent = message;
            if (isError) {
                statusMessage.className = 'text-center text-red-400 font-medium h-6';
                console.error(message);
            } else {
                statusMessage.className = 'text-center text-green-400 font-medium h-6';
                console.log(message);
            }
        }
        
        /**
         * Initializes AudioContext and MediaStream to detect microphone sample rate and channel count.
         */
        async function detectMicProperties() {
            // Only detect if needed
            if (micBaseRate > 0 && micChannelCount > 0) return { rate: micBaseRate, channels: micChannelCount };

            let context;
            let stream;
            let result = { rate: 44100, channels: 1 }; // Default fallback

            try {
                // 1. Detect base rate via AudioContext
                context = new (window.AudioContext || window.webkitAudioContext)();
                result.rate = context.sampleRate;

                // 2. Detect channel count via MediaStream
                // Request minimal audio stream access just to check settings
                stream = await navigator.mediaDevices.getUserMedia({ audio: { echoCancellation: false, noiseSuppression: false, autoGainControl: false } });

                const tracks = stream.getAudioTracks();
                if (tracks.length > 0) {
                    const settings = tracks[0].getSettings();
                    // Fallback to 1 if settings don't provide channelCount (unlikely for modern browsers)
                    result.channels = settings.channelCount || 1; 
                }

            } catch (e) {
                // This typically means the user denied microphone access or it's unavailable.
                console.warn("Could not detect microphone properties (rate or channels). Using fallbacks (44.1kHz, Mono).", e);
                // Fallback result is already set
            } finally {
                // Stop stream immediately
                if (stream) {
                    stream.getTracks().forEach(track => track.stop());
                }
                // Attempt to close the context
                if (context && context.state !== 'closed' && context.close) {
                     context.close().catch(e => console.error("Error closing context:", e));
                }
            }
            
            // Cache the results before returning
            micBaseRate = result.rate;
            micChannelCount = result.channels;

            return result;
        }


        /**
         * Updates the displayed base and calculated PDM rates for the Mic input section.
         */
        async function updateMicRates() {
            const OSR = parseInt(document.getElementById('micOsr').value);
            const micBaseRateElement = document.getElementById('micBaseRate');
            const micCalculatedPdmRateElement = document.getElementById('micCalculatedPdmRate');
            const micChannelsElement = document.getElementById('micChannels'); 

            // 1. Wait for properties detection if not yet done or if 'mic' is selected
            if (micBaseRate === 0 || micChannelCount === 0 || document.getElementById('signalType').value === 'mic') {
                micBaseRateElement.textContent = "Detecting...";
                micChannelsElement.textContent = "Detecting...";
                const properties = await detectMicProperties();
                micBaseRate = properties.rate;
                micChannelCount = properties.channels;
            }

            const baseRate = micBaseRate;
            const channels = micChannelCount; 

            micBaseRateElement.textContent = baseRate.toLocaleString();
            
            let channelText = `${channels} (${channels === 1 ? 'Mono' : 'Stereo/Multi'})`;
            if (channels === 0) channelText = 'Unknown (Access Denied)';
            micChannelsElement.textContent = channelText;

            if (!isNaN(OSR) && OSR >= 2 && baseRate > 0) {
                const pdmRate = baseRate * OSR;
                micCalculatedPdmRateElement.textContent = Math.round(pdmRate).toLocaleString();
            } else {
                micCalculatedPdmRateElement.textContent = 'N/A';
            }
        }

        // --- UI Toggling Logic for Section 1 ---
        function toggleSignalInputs() {
            const type = document.getElementById('signalType').value;
            const synthParams = document.getElementById('synthParams');
            const micParams = document.getElementById('micParams');
            const button = document.getElementById('generatePdmButton');

            if (type === 'mic') {
                synthParams.classList.add('hidden');
                micParams.classList.remove('hidden');
                button.textContent = "Start Recording & Download PDM";

                // Display Mic properties on selection and ensure dynamic updates
                updateMicRates();

            } else {
                synthParams.classList.remove('hidden');
                micParams.classList.add('hidden');
                button.textContent = "Generate & Download PDM (.bin)";
            }
        }

        // --- CORE PDM FUNCTIONS ---

        /**
         * Generates analog audio samples based on the signal type (Sine, Square, Noise).
         * @param {string} type - 'sine', 'square', or 'noise'.
         * @param {number} freq - Signal frequency.
         * @param {number} rate - Sample rate (PDM rate).
         * @param {number} duration - Duration in seconds.
         * @returns {Float32Array} Array of samples between -1.0 and 1.0.
         */
        function generateAnalogSignal(type, freq, rate, duration) {
            const numSamples = Math.floor(rate * duration);
            const samples = new Float32Array(numSamples);

            for (let i = 0; i < numSamples; i++) {
                const t = i / rate; // time
                const amplitude = 0.5; // Use 0.5 to avoid clipping in the SDM

                switch (type) {
                    case 'sine':
                        samples[i] = amplitude * Math.sin(2 * Math.PI * freq * t);
                        break;
                    case 'square':
                        // Simple square wave approximation using sine phase
                        samples[i] = Math.sign(Math.sin(2 * Math.PI * freq * t)) * amplitude;
                        break;
                    case 'noise':
                        // White Noise (between -amplitude and +amplitude)
                        samples[i] = (Math.random() * 2 - 1) * amplitude;
                        break;
                    default:
                        samples[i] = 0;
                        break;
                }
            }
            return samples;
        }

        /**
         * Converts analog PCM samples to a raw PDM bitstream using a 1st-order Sigma-Delta Modulator.
         * @param {Float32Array} analogSamples - Input PCM samples (-1.0 to 1.0).
         * @returns {ArrayBuffer} Raw PDM bitstream packed into bytes.
         */
        function samplesToPDM(analogSamples) {
             // Reset integrator for unipolar S-D
            let integrator = 0.0;
            const numSamples = analogSamples.length;
            const numBytes = Math.ceil(numSamples / 8);
            const buffer = new ArrayBuffer(numBytes);
            const view = new DataView(buffer);

            let byteIndex = 0;
            let bitPosition = 0; // LSB first
            let currentByte = 0;

            for (let i = 0; i < numSamples; i++) {
                // Scale input from [-1, 1] to [0, 1] for unipolar S-D
                const inputScaled = (analogSamples[i] / 2.0) + 0.5; 

                // 1. Integration
                integrator += inputScaled;
                let outputBit;

                // 2. Quantization (0 or 1)
                if (integrator >= 0.5) { // Quantize to 1
                    outputBit = 1;
                    integrator -= 1.0; // Feedback is 1.0
                } else { // Quantize to 0
                    outputBit = 0;
                    // Feedback is 0.0 (already done)
                }

                // Pack the bit (LSB first)
                if (outputBit === 1) {
                    currentByte |= (1 << bitPosition);
                }

                bitPosition++;

                if (bitPosition >= 8) {
                    view.setUint8(byteIndex, currentByte);
                    byteIndex++;
                    currentByte = 0;
                    bitPosition = 0;
                }
            }

            // Write the last, partially filled byte
            if (bitPosition > 0) {
                view.setUint8(byteIndex, currentByte);
            }

            return buffer;
        }
        
        // --- SECTION 1: MAIN HANDLER (SYNTH & MIC) ---

        async function handleGeneratePDM() {
            const type = document.getElementById('signalType').value;
            const duration = parseFloat(document.getElementById('duration').value);

            if (isNaN(duration) || duration <= 0) {
                setStatus("Invalid Duration value.", true);
                return;
            }

            if (type === 'mic') {
                await generatePDMFromMic(duration); 
            } else {
                await generatePDMFromSynth(type, duration);
            }
        }

        async function generatePDMFromSynth(type, duration) {
            setStatus(`Synthesizing Analog Signal...`);
            try {
                const freq = parseFloat(document.getElementById('signalFreq').value);
                const rate = parseFloat(document.getElementById('pdmRate').value); // This is the PDM rate
                
                if (isNaN(freq) || isNaN(rate) || rate <= 0) {
                    setStatus("Invalid synthetic signal parameters.", true);
                    return;
                }
                if (freq > rate / 2) {
                    setStatus(`Warning: Signal Frequency (${freq} Hz) exceeds Nyquist limit of PDM Rate / 2 (${rate / 2} Hz). PDM fidelity will be low.`, true);
                }

                const analogSamples = generateAnalogSignal(type, freq, rate, duration);
                const totalSamples = analogSamples.length;

                setStatus(`Synthesizing Analog Signal (Total Samples: ${totalSamples.toLocaleString()}). Applying Sigma-Delta Modulation...`, false);

                // Proceed with PDM conversion and download
                const pdmBitstream = samplesToPDM(analogSamples);

                downloadFile(pdmBitstream, `${type}-${freq}Hz_r${rate}Hz.bin`, 'application/octet-stream');

                // Update the Input PDM Rate in Section 2
                document.getElementById('inputPdmRate').value = Math.floor(rate);

                setStatus(`Successfully generated PDM binary file for ${type}.`);
            } catch (error) {
                setStatus(`Error during PDM generation: ${error.message}`, true);
            }
        }


        async function generatePDMFromMic(duration) {
            setStatus("Requesting microphone access...");
            const OSR = parseInt(document.getElementById('micOsr').value);
            const button = document.getElementById('generatePdmButton');

            if (isNaN(OSR) || OSR < 2) {
                setStatus("Invalid Oversampling Ratio (OSR). Must be 2 or greater.", true);
                return;
            }

            button.disabled = true;
            button.textContent = "Starting...";

            let audioContext;
            let stream;
            let source;
            let processor;
            const recordedSamples = [];

            try {
                // 1. Get Microphone Stream
                // Note: Constraints here ensure mono acquisition if the device/browser supports it
                stream = await navigator.mediaDevices.getUserMedia({ audio: { channelCount: 1 } });
                audioContext = new (window.AudioContext || window.webkitAudioContext)();

                const sourceRate = audioContext.sampleRate;
                const pdmRate = sourceRate * OSR;
                
                // Although we requested mono (channelCount: 1), we check the actual channels
                const actualChannels = stream.getAudioTracks()[0].getSettings().channelCount || 1; 

                if (actualChannels > 1) {
                     // If the device ignores our mono request, we only process the first channel later
                     console.warn(`Device provided ${actualChannels} channels despite requesting 1. Only processing the first channel.`);
                }

                setStatus(`Mic acquired! Base PCM Rate: ${sourceRate.toLocaleString()} Hz. Target PDM Rate: ${pdmRate.toLocaleString()} Hz (OSR=${OSR}). Recording for ${duration} seconds...`);

                // Create source from the stream
                source = audioContext.createMediaStreamSource(stream);

                // Use a ScriptProcessorNode for sample access (for this demo's simplicity)
                const bufferSize = 4096;
                // Output is forced to mono (1) for this PDM pipeline
                processor = audioContext.createScriptProcessor(bufferSize, actualChannels, 1); 

                let samplesRecorded = 0;
                const totalSamplesToRecord = Math.ceil(sourceRate * duration);

                processor.onaudioprocess = (e) => {
                    if (samplesRecorded >= totalSamplesToRecord) return;

                    // IMPORTANT: Only take the first channel's data for conversion
                    const inputData = e.inputBuffer.getChannelData(0);

                    const remaining = totalSamplesToRecord - samplesRecorded;
                    const takeCount = Math.min(inputData.length, remaining);

                    const chunk = inputData.slice(0, takeCount);
                    recordedSamples.push(chunk);
                    samplesRecorded += takeCount;

                    const progress = Math.min(100, Math.floor((samplesRecorded / totalSamplesToRecord) * 100));
                    button.textContent = `Recording... ${progress}%`;

                    if (samplesRecorded >= totalSamplesToRecord) {
                        stopRecording();
                        processRecording(recordedSamples, sourceRate, OSR, pdmRate);
                    }
                };

                source.connect(processor);
                processor.connect(audioContext.destination);

                // Timeout as a failsafe
                setTimeout(() => {
                    if (stream) {
                        stopRecording();
                        processRecording(recordedSamples, sourceRate, OSR, pdmRate);
                    }
                }, duration * 1000 + 500);

            } catch (error) {
                setStatus(`Error accessing microphone: ${error.message}. Please check permissions.`, true);
                stopRecording();
            }

            function stopRecording() {
                if (stream) {
                    stream.getTracks().forEach(track => track.stop());
                    stream = null;
                }
                if (source) {
                    source.disconnect();
                    source = null;
                }
                if (processor) {
                    processor.disconnect();
                    processor = null;
                }
                if (audioContext && audioContext.state !== 'closed') {
                    audioContext.close();
                }
                button.disabled = false;
                toggleSignalInputs(); // Reset button text based on selection
            }

            async function processRecording(recordedSamples, sourceRate, OSR, pdmRate) {
                setStatus("Processing recorded audio: Combining and resampling...");

                if (recordedSamples.length === 0) {
                    setStatus("No audio was recorded.", true);
                    return;
                }

                // 2. Concatenate all recorded chunks
                const finalSamplesLength = recordedSamples.reduce((acc, arr) => acc + arr.length, 0);
                const combinedData = new Float32Array(finalSamplesLength);
                let offset = 0;
                recordedSamples.forEach(arr => {
                    combinedData.set(arr, offset);
                    offset += arr.length;
                });
                
                // 3. Resample (Interpolation)
                const resampleRatio = pdmRate / sourceRate;
                const newLength = Math.ceil(combinedData.length * resampleRatio);
                const resampledData = new Float32Array(newLength);

                for (let i = 0; i < newLength; i++) {
                    // Linear interpolation for resampling
                    const oldIndex = i / resampleRatio;
                    const floorIndex = Math.floor(oldIndex);
                    const ceilIndex = Math.min(combinedData.length - 1, floorIndex + 1);
                    const frac = oldIndex - floorIndex;

                    const sampleA = combinedData[floorIndex];
                    const sampleB = combinedData[ceilIndex];

                    resampledData[i] = sampleA + (sampleB - sampleA) * frac;
                }

                // 4. Convert resampled PCM to PDM bitstream
                setStatus(`Applying Sigma-Delta Modulation... Total PDM bits (samples): ${newLength.toLocaleString()}`);
                const pdmBitstream = samplesToPDM(resampledData);

                downloadFile(pdmBitstream, `mic_osr${OSR}_${pdmRate}Hz.bin`, 'application/octet-stream');
                setStatus(`Successfully captured and converted Mic to PDM binary. PDM Sample Rate: ${pdmRate.toLocaleString()} Hz.`);

                // Set the calculated PDM rate into the Section 2 input for PDM-to-WAV conversion
                document.getElementById('inputPdmRate').value = Math.floor(pdmRate);
            }
        }


        // --- 2. PDM TO WAV CONVERSION (DECIMATION) ---

        /**
         * Decimates and filters a raw PDM bitstream into a standard PCM Float32Array.
         */
        function pdmToPcm(pdmBuffer, R) {
            const view = new DataView(pdmBuffer);
            const totalBytes = pdmBuffer.byteLength;
            const totalPDMbits = totalBytes * 8;

            const pcmSamples = [];
            let currentSum = 0;
            let bitCount = 0;
            let pcmSampleCounter = 0;

            for (let i = 0; i < totalBytes; i++) {
                const byte = view.getUint8(i);

                for (let j = 0; j < 8; j++) {
                    if (pcmSampleCounter >= totalPDMbits) break;

                    const bit = (byte >> j) & 1;
                    currentSum += (bit * 2.0 - 1.0); // 0 -> -1.0, 1 -> 1.0

                    bitCount++;

                    if (bitCount >= R) {
                        const pcmValue = currentSum / R;
                        pcmSamples.push(pcmValue);

                        currentSum = 0;
                        bitCount = 0;
                    }
                    pcmSampleCounter++;
                }
            }

            return new Float32Array(pcmSamples);
        }

        /**
         * Writes a WAV file header and data chunk.
         */
        function encodeWav(pcmData, sampleRate, bitDepth, formatCode) {
            const numChannels = 1; // Since PDM is inherently mono for this process
            const bytesPerSample = bitDepth / 8;
            const numSamples = pcmData.length;

            // Note: For 24-bit, bytesPerSample will be 3, which is correctly used here.
            const dataSize = numSamples * numChannels * bytesPerSample;
            const fileSize = 36 + dataSize;

            const buffer = new ArrayBuffer(44 + dataSize);
            const view = new DataView(buffer);
            let offset = 0;

            // RIFF Chunk
            writeString('RIFF');
            view.setUint32(offset, fileSize, true); offset += 4;
            writeString('WAVE');

            // FMT Chunk
            writeString('fmt ');
            view.setUint32(offset, 16, true); offset += 4;
            view.setUint16(offset, formatCode, true); offset += 2;
            view.setUint16(offset, numChannels, true); offset += 2;
            view.setUint32(offset, sampleRate, true); offset += 4;
            view.setUint32(offset, sampleRate * numChannels * bytesPerSample, true); offset += 4;
            view.setUint16(offset, numChannels * bytesPerSample, true); offset += 2;
            view.setUint16(offset, bitDepth, true); offset += 2;

            // DATA Chunk
            writeString('data');
            view.setUint32(offset, dataSize, true); offset += 4;

            // PCM Data
            for (let i = 0; i < numSamples; i++) {
                let sample = pcmData[i];
                sample = Math.max(-1, Math.min(1, sample)); // Clamp to -1.0 to 1.0

                if (formatCode === 1) { // PCM (8, 16, 24-bit)
                    if (bitDepth === 8) { // 8-bit Unsigned Integer
                        const scale = 127.5;
                        const scaledSample = Math.round((sample * scale) + scale); // 0 to 255
                        view.setUint8(offset, scaledSample);
                        offset += 1;
                    } else if (bitDepth === 16) { // 16-bit Signed Integer
                        const scale = 32767;
                        view.setInt16(offset, Math.round(sample * scale), true);
                        offset += 2;
                    } else if (bitDepth === 24) { // 24-bit Signed Integer
                        const scale = 8388607; // 2^23 - 1
                        const scaledSample = Math.round(sample * scale);

                        // Write 3 bytes (Little Endian)
                        // Byte 0 (LSB)
                        view.setUint8(offset, scaledSample & 0xFF);
                        // Byte 1
                        view.setUint8(offset + 1, (scaledSample >> 8) & 0xFF);
                        // Byte 2 (MSB)
                        view.setUint8(offset + 2, (scaledSample >> 16) & 0xFF);
                        offset += 3;
                    }
                } else if (formatCode === 3) { // 32-bit IEEE Floating Point
                    view.setFloat32(offset, sample, true);
                    offset += 4;
                }
            }

            return buffer;

            function writeString(s) {
                for (let i = 0; i < s.length; i++) {
                    view.setUint8(offset++, s.charCodeAt(i));
                }
            }
        }

        async function handlePdmToWav() {
            setStatus("Starting PDM to WAV conversion...");
            const fileInput = document.getElementById('pdmFile');
            const R = parseInt(document.getElementById('decimationFactor').value);
            const inputPdmRate = parseFloat(document.getElementById('inputPdmRate').value);
            const bitDepthInput = document.getElementById('outputBitDepth').value;

            if (fileInput.files.length === 0) {
                setStatus("Please select a PDM binary file.", true);
                return;
            }
            if (isNaN(R) || R < 2 || isNaN(inputPdmRate) || inputPdmRate <= 0) {
                setStatus("Invalid PDM conversion parameters.", true);
                return;
            }

            try {
                let bitDepth, formatCode;

                if (bitDepthInput === '32f') {
                    bitDepth = 32;
                    formatCode = 3; // IEEE Float
                } else {
                    bitDepth = parseInt(bitDepthInput, 10);
                    formatCode = 1;
                }

                const pdmBuffer = await fileInput.files[0].arrayBuffer();
                const totalPDMbits = pdmBuffer.byteLength * 8;

                const pcmSamples = pdmToPcm(pdmBuffer, R);
                const pcmRate = Math.floor(inputPdmRate / R);
                
                if (pcmSamples.length === 0) {
                    setStatus("No PCM samples could be generated.", true);
                    return;
                }

                const wavBuffer = encodeWav(pcmSamples, pcmRate, bitDepth, formatCode);

                downloadFile(wavBuffer, `decoded_pdm_r${R}_${pcmRate}Hz_${bitDepth}bit.wav`, 'audio/wav');
                setStatus(`Successfully converted PDM to WAV. PDM Bits: ${totalPDMbits.toLocaleString()}. PCM Sample Rate: ${pcmRate.toLocaleString()} Hz, PCM Samples: ${pcmSamples.length.toLocaleString()}, Bit Depth: ${bitDepth}.`);

            } catch (error) {
                setStatus(`Error during PDM to WAV conversion: ${error.message}`, true);
            }
        }


        // --- 3. WAV TO PDM CONVERSION (OVERSAMPLING) ---

        async function handleWavToPdm() {
            setStatus("Starting WAV to PDM conversion...");
            const fileInput = document.getElementById('wavFile');
            const OSR = parseInt(document.getElementById('osr').value);

            if (fileInput.files.length === 0) {
                setStatus("Please select a WAV file.", true);
                return;
            }
            if (isNaN(OSR) || OSR < 2) {
                setStatus("Invalid Oversampling Ratio (OSR). Must be 2 or greater.", true);
                return;
            }

            let audioContext;
            try {
                // 1. Decode WAV file using Web Audio API
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const fileArrayBuffer = await fileInput.files[0].arrayBuffer();
                const audioBuffer = await audioContext.decodeAudioData(fileArrayBuffer);

                const sourceRate = audioBuffer.sampleRate;
                const pdmRate = sourceRate * OSR;

                // Check if mono or just take the first channel if multi-channel
                let sourceData;
                if (audioBuffer.numberOfChannels > 1) {
                    console.warn(`Input WAV file has ${audioBuffer.numberOfChannels} channels. Only using the first channel for PDM conversion.`);
                    sourceData = audioBuffer.getChannelData(0);
                } else {
                    sourceData = audioBuffer.getChannelData(0);
                }
                
                // 2. Resample the PCM data to the PDM rate
                setStatus(`Original PCM Rate: ${sourceRate.toLocaleString()} Hz. Total Samples: ${sourceData.length.toLocaleString()}.`);
                setStatus(`Resampling PCM to PDM Rate: ${pdmRate.toLocaleString()} Hz (OSR=${OSR})...`);

                const resampleRatio = pdmRate / sourceRate;
                const newLength = Math.ceil(sourceData.length * resampleRatio);
                const resampledData = new Float32Array(newLength);

                for (let i = 0; i < newLength; i++) {
                    // Linear interpolation for resampling
                    const oldIndex = i / resampleRatio;
                    const floorIndex = Math.floor(oldIndex);
                    const ceilIndex = Math.min(sourceData.length - 1, floorIndex + 1);
                    const frac = oldIndex - floorIndex;

                    const sampleA = sourceData[floorIndex];
                    const sampleB = sourceData[ceilIndex];

                    resampledData[i] = sampleA + (sampleB - sampleA) * frac;
                }

                // 3. Convert resampled PCM to PDM bitstream
                setStatus(`Applying Sigma-Delta Modulation... Total PDM bits (samples): ${newLength.toLocaleString()}`);
                const pdmBitstream = samplesToPDM(resampledData);

                downloadFile(pdmBitstream, `encoded_wav_osr${OSR}_${pdmRate}Hz.bin`, 'application/octet-stream');
                setStatus(`Successfully converted WAV to PDM binary. PDM Sample Rate: ${pdmRate.toLocaleString()} Hz.`);

            } catch (error) {
                setStatus(`Error during WAV to PDM conversion: ${error.message}`, true);
            } finally {
                 // Ensure AudioContext is closed if created
                 if (audioContext && audioContext.state !== 'closed') {
                    audioContext.close();
                }
            }
        }

    </script>
</body>
</html>

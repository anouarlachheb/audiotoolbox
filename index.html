<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>PDM & WAV Toolbox</title>
<script src="https://cdn.tailwindcss.com"></script>
<style>
body { font-family: 'Inter', sans-serif; background-color:#0b1220; color:#e6eef8; }
.section-card { background: linear-gradient(180deg,#0f1724,#111827); border:1px solid rgba(99,102,241,0.06); padding:1rem; border-radius:1rem; }
.progress { height:8px; background:#111827; border-radius:999px; overflow:hidden; }
.progress > i { display:block; height:100%; width:0%; background:linear-gradient(90deg,#4f46e5,#06b6d4); transition:width .15s linear; }
canvas { background:#071126; border-radius:8px; display:block; }
.plot-box { border:1px solid #4f46e5; border-radius:8px; padding:8px; margin-top:0.5rem; }
</style>
</head>
<body class="p-6 md:p-10">
<div class="max-w-6xl mx-auto space-y-6">

<h1 class="text-3xl font-bold text-indigo-300 text-center">PDM & WAV Signal Processing Toolbox</h1>
<p id="status-message" class="text-center text-sm h-6"></p>

<div class="grid grid-cols-1 lg:grid-cols-3 gap-6">

<!-- Section #1: Generate PDM -->
<div class="section-card">
<h2 class="text-xl font-semibold text-indigo-200 mb-3">1. Generate PDM</h2>
<label class="block text-sm text-gray-300">Signal</label>
<select id="signalType" onchange="toggleSignalInputs()" class="w-full p-2 rounded mt-1 bg-gray-800">
<option value="sine">Synthetic: Sine</option>
<option value="square">Synthetic: Square</option>
<option value="noise">Synthetic: Noise</option>
<option value="mic">Microphone</option>
</select>

<div id="synthParams" class="mt-3 space-y-2">
<input id="signalFreq" type="number" value="1000" min="1" class="w-full p-2 rounded bg-gray-800" />
<input id="pdmRate" type="number" value="3076864" class="w-full p-2 rounded bg-gray-800" />
</div>

<div id="micParams" class="mt-3 space-y-2 hidden">
<input id="micOsr" type="number" value="64" min="2" class="w-full p-2 rounded bg-gray-800" oninput="updateMicRates()" />
<div class="p-3 rounded bg-gray-900 text-xs">
<div>Base Rate: <span id="micBaseRate">N/A</span></div>
<div>PDM Rate: <span id="micCalculatedPdmRate">N/A</span></div>
<div>Channels: <span id="micChannels">N/A</span></div>
</div>
</div>

<input id="duration" type="number" step="0.1" value="1.0" class="w-full p-2 rounded mt-3 bg-gray-800" />
<div class="mt-3">
<button id="generatePdmButton" onclick="handleGeneratePDM()" class="w-full p-2 rounded bg-indigo-600">Generate / Record PDM</button>
</div>
<div class="mt-3 text-xs">
<div class="progress"><i id="genProgress"></i></div>
</div>
</div>

<!-- Section #2: PDM → WAV -->
<div class="section-card">
<h2 class="text-xl font-semibold text-indigo-200 mb-3">2. PDM → WAV</h2>
<input id="pdmFile" type="file" accept=".bin,.pdm" class="w-full p-2 rounded bg-gray-800" />
<label class="block mt-2 text-sm text-gray-300">Decimation</label>
<input id="decimationFactor" type="number" value="64" class="w-full p-2 rounded bg-gray-800" />
<select id="decimationAlgo" class="w-full p-2 rounded bg-gray-800 mt-2">
  <option value="sinc1">Sinc-1 (MA)</option>
  <option value="sinc2">Sinc-2 (Cascaded)</option>
  <option value="sinc3">Sinc-3 (Cascaded MA x3)</option>
  <option value="cic1">CIC (Order 1)</option>
  <option value="cic2">CIC (Order 2)</option>
  <option value="cic3" selected>CIC (Order 3)</option>
  <option value="cic4">CIC (Order 4)</option>
  <option value="cic5">CIC (Order 5)</option>
  <option value="cic3_fir">CIC (3) + FIR compensation</option>
  <option value="fir">FIR only (custom FIR)</option>
  <option value="movingaverage">Moving Average (MA)</option>
  <option value="raw_downsample">Raw downsample (no filter) - not recommended</option>
</select>
<input id="inputPdmRate" type="number" value="3076864" class="w-full p-2 rounded bg-gray-800 mt-2" />

<div class="flex items-center mt-2 gap-2">
<select id="outputBitDepth" class="p-2 rounded bg-gray-800">
<option value="8">8-bit</option>
<option value="16" selected>16-bit</option>
<option value="24">24-bit</option>
<option value="32f">32-bit float</option>
</select>
<span class="text-gray-400 text-sm">Output bit depth</span>
</div>

<div class="mt-3">
<button onclick="handlePdmToWav()" class="w-full p-2 rounded bg-indigo-600">Convert</button>
</div>
<div class="mt-3 text-xs">
<div class="progress"><i id="pdm2wavProgress"></i></div>
</div>

<!-- Plots -->
<div class="plot-box">
<h3 class="text-sm text-gray-300">Time-domain</h3>
<canvas id="timeCanvas"></canvas>
</div>
<div class="plot-box">
<h3 class="text-sm text-gray-300">FFT (Magnitude)</h3>
<canvas id="fftCanvas" ></canvas>
</div>
</div>

<!-- Section #3: WAV → PDM -->
<div class="section-card">
<h2 class="text-xl font-semibold text-indigo-200 mb-3">3. WAV → PDM</h2>
<input id="wavFile" type="file" accept=".wav" class="w-full p-2 rounded bg-gray-800" />
<input id="osr" type="number" value="64" class="w-full p-2 rounded bg-gray-800 mt-2" />
<div class="mt-3">
<button onclick="handleWavToPdm()" class="w-full p-2 rounded bg-indigo-600">Convert</button>
</div>
<div class="mt-3 text-xs">
<div class="progress"><i id="wav2pdmProgress"></i></div>
</div>
</div>

<!-- Section #4: Playback -->
<div class="section-card">
<h2 class="text-xl font-semibold text-indigo-200 mb-3">4. Playback</h2>
<input id="playbackFile" type="file" accept=".wav,.bin,.pdm" class="w-full p-2 rounded bg-gray-800" />
<button onclick="handlePlayback()" class="w-full p-2 rounded bg-indigo-600 mt-2">Play</button>
<button onclick="stopPlayback()" class="w-full p-2 rounded bg-red-600 mt-2">Stop</button>
</div>


</div>
</div>

<script>
// ------------------- Utilities -------------------
const statusMessage = document.getElementById('status-message');
function setStatus(msg, isError=false){ statusMessage.textContent = msg; statusMessage.style.color = isError? '#ff7b7b' : '#7ee787'; console.log(msg); }
function setProgress(id, p){ const el = document.getElementById(id); if(el) el.style.width = Math.max(0,Math.min(100,p)) + '%'; }
function timestamp(){ const d=new Date(); return d.toISOString().replace(/[:.]/g,'-'); }

// ------------------- Generate Synthetic PDM -------------------
function generateAnalogSignal(type,freq,rate,duration){
  const n=Math.floor(rate*duration);
  const out=new Float32Array(n);
  const amp=0.5;
  for(let i=0;i<n;i++){
    const t=i/rate;
    if(type==='sine') out[i]=amp*Math.sin(2*Math.PI*freq*t);
    else if(type==='square') out[i]= (Math.sin(2*Math.PI*freq*t)>=0?amp:-amp);
    else out[i]=(Math.random()*2-1)*amp;
  }
  return out;
}

function samplesToPDM(samples){
  let integrator=0;
  const n=samples.length;
  const numBytes=Math.ceil(n/8);
  const out=new Uint8Array(numBytes);
  let byteIdx=0, bitPos=0, cur=0;
  for(let i=0;i<n;i++){
    const s=(samples[i]/2)+0.5;
    integrator+=s;
    let ob=0; if(integrator>=0.5){ ob=1; integrator-=1; }
    if(ob) cur|=(1<<bitPos);
    bitPos++;
    if(bitPos>=8){ out[byteIdx++]=cur; cur=0; bitPos=0; }
  }
  if(bitPos>0) out[byteIdx]=cur;
  return out.buffer;
}

// ------------------- handleGeneratePDM -------------------
async function handleGeneratePDM(){
  const type=document.getElementById('signalType').value;
  const duration=parseFloat(document.getElementById('duration').value||'1');
  if(type==='mic'){ await generatePDMFromMic(duration); return; }
  setStatus('Generating synthetic...');
  const freq=parseFloat(document.getElementById('signalFreq').value||'1000');
  const rate=parseFloat(document.getElementById('pdmRate').value||'3076864');
  const analog=generateAnalogSignal(type,freq,rate,duration);
  setStatus('Converting to PDM...');
  const pdm=samplesToPDM(analog);
  const name=`pdm_${type}_${freq}Hz_r${Math.floor(rate)}Hz_${timestamp()}.bin`;
  downloadFile(pdm,name,'application/octet-stream');
  setStatus('Download ready');
  setProgress('genProgress',100);
  document.getElementById('inputPdmRate').value=Math.floor(rate);
}

// ------------------- Microphone capture -------------------
async function generatePDMFromMic(duration){
  setStatus('Requesting mic...');
  const OSR=parseInt(document.getElementById('micOsr').value||'64');
  if(OSR<2){ setStatus('OSR must be >=2', true); return; }
  try{
    const stream=await navigator.mediaDevices.getUserMedia({audio:{channelCount:1}});
    const ac=new (window.AudioContext||window.webkitAudioContext)();
    const src=ac.createMediaStreamSource(stream);
    const bufferSize=1024;
    const processor=ac.createScriptProcessor(bufferSize,1,0);
    const rate=ac.sampleRate;
    const pdmRate=rate*OSR;
    const recordedChunks=[];
    let recorded=0, totalToRecord=Math.ceil(rate*duration);

    processor.onaudioprocess=(e)=>{
      const data=e.inputBuffer.getChannelData(0);
      const take=Math.min(data.length,totalToRecord-recorded);
      if(take<=0) return;
      recordedChunks.push(data.slice(0,take));
      recorded+=take;
      setProgress('genProgress',Math.floor((recorded/totalToRecord)*100));
      if(recorded>=totalToRecord){
        processor.disconnect(); src.disconnect(); stream.getTracks().forEach(t=>t.stop()); ac.close();
        processMicChunks(recordedChunks, rate, OSR, pdmRate);
      }
    };
    src.connect(processor);
    setStatus(`Recording ${duration}s @${rate}Hz -> PDM ${pdmRate}Hz`);
    setTimeout(()=>{ if(recorded<totalToRecord){ processor.disconnect(); src.disconnect(); stream.getTracks().forEach(t=>t.stop()); ac.close(); processMicChunks(recordedChunks, rate, OSR, pdmRate); }}, (duration+1)*1000);
  }catch(err){ setStatus('Mic error: '+err.message,true); }
}

function processMicChunks(chunks, rate, OSR, pdmRate){
  setStatus('Processing mic data...');
  const total=chunks.reduce((a,c)=>a+c.length,0);
  const combined=new Float32Array(total); let off=0;
  for(const c of chunks){ combined.set(c,off); off+=c.length; }
  const resampled=new Float32Array(Math.ceil(combined.length*OSR));
  for(let i=0;i<resampled.length;i++){
    const old=i/OSR; const f=Math.floor(old);
    const c=Math.min(combined.length-1,f+1);
    const frac=old-f;
    resampled[i]=combined[f]+(combined[c]-combined[f])*frac;
  }
  const pdm=samplesToPDM(resampled);
  const name=`mic_osr${OSR}_${Math.floor(pdmRate)}Hz_${timestamp()}.bin`;
  downloadFile(pdm,name,'application/octet-stream');
  setStatus('Mic PDM ready');
  setProgress('genProgress',100);
  document.getElementById('inputPdmRate').value=Math.floor(pdmRate);
}

// ------------------- PDM → WAV -------------------
async function handlePdmToWav(){
  if(!document.getElementById('pdmFile').files.length){ setStatus('Select a PDM file',true); return; }
  const file=document.getElementById('pdmFile').files[0];
  const R=parseInt(document.getElementById('decimationFactor').value||'64');
  const algo=document.getElementById('decimationAlgo').value;
  const inRate=parseFloat(document.getElementById('inputPdmRate').value||'3076864');
  const bitDepth=document.getElementById('outputBitDepth').value==='32f'?32:parseInt(document.getElementById('outputBitDepth').value);

  setStatus('Reading file...');
  const ab=await file.arrayBuffer();
  setProgress('pdm2wavProgress',10);

  try{
    setStatus('Decimating...');
    const pcm=decimatePDM(new Uint8Array(ab), R, algo); // returns Float32Array mono
    setProgress('pdm2wavProgress',70);

    const pcmRate=Math.floor(inRate/R);
    const wavBuffer=encodeWavMonoStereo(pcm, pcmRate, bitDepth);
    const name=`decoded_pdm_${algo}_r${R}_${pcmRate}Hz_${bitDepth}bit_${timestamp()}.wav`;
    downloadFile(wavBuffer,name,'audio/wav');
    setProgress('pdm2wavProgress',100);
    setStatus('PDM → WAV done');

    // visualize
    drawTimeDomain(pcm.slice(0, Math.min(16384, pcm.length)));
    const mag=computeMagnitude(pcm.slice(0,Math.min(4096, pcm.length)));
    drawFFT(mag);

  }catch(err){ setStatus('Conversion error: '+err.message,true); }
}

// ------------------- WAV → PDM -------------------
async function handleWavToPdm(){
  if(!document.getElementById('wavFile').files.length){ setStatus('Select WAV', true); return; }
  const file=document.getElementById('wavFile').files[0];
  const OSR=parseInt(document.getElementById('osr').value||'64');
  setStatus('Decoding audio...');
  const ac=new (window.AudioContext||window.webkitAudioContext)();
  const ab=await file.arrayBuffer();
  const audioBuffer=await ac.decodeAudioData(ab);
  const sourceRate=audioBuffer.sampleRate;
  const pdmRate=sourceRate*OSR;

  const channels=audioBuffer.numberOfChannels;
  let pdmBuffer;
  if(channels>1){
    const left=audioBuffer.getChannelData(0);
    const right=audioBuffer.getChannelData(1);
    const resL=resampleLinear(left, sourceRate, pdmRate);
    const resR=resampleLinear(right, sourceRate, pdmRate);
    const pdmL=new Uint8Array(samplesToPDM(resL));
    const pdmR=new Uint8Array(samplesToPDM(resR));
    pdmBuffer=new Uint8Array(pdmL.length + pdmR.length);
    for(let i=0;i<pdmBuffer.length;i++){ pdmBuffer[i]=(i%2===0)?(pdmL[i>>1]||0):(pdmR[i>>1]||0); }
  }else{
    const sourceData=audioBuffer.getChannelData(0);
    const res=resampleLinear(sourceData, sourceRate, pdmRate);
    pdmBuffer=new Uint8Array(samplesToPDM(res));
  }

  const name=file.name.replace(/\.[^.]+$/,'')+'_pdm.bin';
  downloadFile(pdmBuffer.buffer,name,'application/octet-stream');
  setProgress('wav2pdmProgress',100);
  setStatus('WAV → PDM done');
  ac.close();
}

// ------------------- Helpers -------------------
function toggleSignalInputs(){
  const t=document.getElementById('signalType').value;
  document.getElementById('synthParams').style.display=(t!=='mic')?'block':'none';
  document.getElementById('micParams').style.display=(t==='mic')?'block':'none';
}

function updateMicRates(){
  const osr=parseInt(document.getElementById('micOsr').value||'64');
  const baseRate=48000;
  document.getElementById('micBaseRate').textContent=baseRate+' Hz';
  document.getElementById('micCalculatedPdmRate').textContent=(baseRate*osr)+' Hz';
  document.getElementById('micChannels').textContent=1;
}

function downloadFile(buffer,filename,type){
  const blob=new Blob([buffer],{type:type||'application/octet-stream'});
  const url=URL.createObjectURL(blob);
  const a=document.createElement('a'); a.href=url; a.download=filename; document.body.appendChild(a); a.click(); setTimeout(()=>{ URL.revokeObjectURL(url); a.remove(); },100);
}

function resampleLinear(data, oldRate, newRate){
  const ratio=newRate/oldRate;
  const newLen=Math.ceil(data.length*ratio);
  const out=new Float32Array(newLen);
  for(let i=0;i<newLen;i++){
    const old=i/ratio; const f=Math.floor(old); const c=Math.min(data.length-1,f+1);
    const frac=old-f;
    out[i]=data[f]+(data[c]-data[f])*frac;
  }
  return out;
}

// ------------------- PDM Decimation (multi-algo) -------------------

// A small, example FIR compensation kernel (tweak for your R to improve response)
const FIR_COEFFS_EXAMPLE = [
  -0.001, -0.002, 0.000, 0.005, 0.012,
   0.020,  0.028, 0.032, 0.028, 0.015, -0.008
];

// utility to read PDM bit (returns +1/-1)
function pdmBitSigned(pdmData, i) {
  return ((pdmData[i >> 3] >> (i & 7)) & 1) ? 1 : -1;
}

function normalizeToFloat32(arr) {
  // arr is Float32Array
  let max = 0;
  for (let i = 0; i < arr.length; i++) max = Math.max(max, Math.abs(arr[i]));
  if (max <= 0) return arr;
  for (let i = 0; i < arr.length; i++) arr[i] = arr[i] / max;
  return arr;
}

function decimatePDM(pdmData, R, algo = "sinc1") {
  // return Float32Array normalized to [-1,1]
  algo = (algo||'sinc1').toLowerCase();

  // handle old "cic3" style tokens
  if (/^cic\d+(_fir)?$/.test(algo)) {
    // e.g. cic3 or cic3_fir
    const order = parseInt(algo.match(/^cic(\d+)/)[1]);
    const withFir = algo.indexOf('_fir')>-1;
    return decimCIC(pdmData, R, order, withFir);
  }

  switch(algo){
    case 'sinc1': return decimSinc(pdmData, R, 1);
    case 'sinc2': return decimSinc(pdmData, R, 2);
    case 'sinc3': return decimSinc(pdmData, R, 3);
    case 'cic': return decimCIC(pdmData, R, 3, false); // keep backward compat
    case 'cic_fir': return decimCIC(pdmData, R, 3, true);
    case 'cic3_fir': return decimCIC(pdmData, R, 3, true);
    case 'cic1': return decimCIC(pdmData, R, 1, false);
    case 'cic2': return decimCIC(pdmData, R, 2, false);
    case 'cic3': return decimCIC(pdmData, R, 3, false);
    case 'cic4': return decimCIC(pdmData, R, 4, false);
    case 'cic5': return decimCIC(pdmData, R, 5, false);
    case 'fir': return decimFIR(pdmData, R, FIR_COEFFS_EXAMPLE);
    case 'movingaverage':
    case 'ma': return decimSinc(pdmData, R, 1);
    case 'raw_downsample': return decimRaw(pdmData, R);
    default:
      console.warn('Unknown decimation algo:', algo, '-> using sinc1');
      return decimSinc(pdmData, R, 1);
  }
}

// ---------- CIC decimator (order N) ----------
function decimCIC(pdmData, R, order=3, applyFir=false) {
  const nBits = pdmData.length * 8;
  const outLen = Math.floor(nBits / R);
  const out = new Float32Array(outLen);

  // Integrators (accumulate)
  const integrators = new Array(order).fill(0);
  // Comb delay memory (previous samples)
  const combDelay = new Array(order).fill(0);

  let idx = 0;
  // CIC integrator-run (per sample)
  for (let i = 0; i < nBits; i++) {
    const x = pdmBitSigned(pdmData, i);

    // integrator cascade
    integrators[0] += x;
    for (let j = 1; j < order; j++) integrators[j] += integrators[j-1];

    // on decimation boundary, sample integrator and run comb
    if ((i % R) === 0) {
      let v = integrators[order-1];
      // comb cascade (v - delayed_v)
      for (let j = 0; j < order; j++) {
        const delayed = combDelay[j];
        combDelay[j] = v;
        v = v - delayed;
      }
      out[idx++] = v;
    }
  }

  // Normalize (CIC gain = (R^order) ideally; but we normalize to [-1..1] for playback)
  normalizeToFloat32(out);

  if (applyFir) {
    // small FIR compensation: convolve with FIR_COEFFS_EXAMPLE then downsample/trim
    return decimFIR_fromPCM(out, 1, FIR_COEFFS_EXAMPLE); // pcm base-rate already decimated; use fir on PCM
  }

  return out;
}

// ---------- SincN decimator (N cascaded moving averages) ----------
function decimSinc(pdmData, R, order=1) {
  const nBits = pdmData.length * 8;
  const outLen = Math.floor(nBits / R);
  const out = new Float32Array(outLen);

  // We'll implement cascaded moving sums that reset every decimation window.
  // Simpler and inexpensive.
  let buffers = new Array(order).fill(0);
  let idx = 0;
  for (let i = 0; i < nBits; i++) {
    const x = pdmBitSigned(pdmData, i);
    buffers[0] += x;
    for (let k = 1; k < order; k++) buffers[k] += buffers[k-1];

    if ((i % R) === 0) {
      out[idx++] = buffers[order-1] / R; // average over the R samples
      buffers = new Array(order).fill(0);
    }
  }

  normalizeToFloat32(out);
  return out;
}

// ---------- Raw downsample (no filtering) ----------
function decimRaw(pdmData, R) {
  const nBits = pdmData.length * 8;
  const outLen = Math.floor(nBits / R);
  const out = new Float32Array(outLen);
  let idx = 0;
  for (let i = 0; i < nBits; i += R) {
    out[idx++] = pdmBitSigned(pdmData, i);
  }
  normalizeToFloat32(out);
  return out;
}

// ---------- FIR decimator operating directly on PDM bits (simple polyphase approach) ----------
function decimFIR(pdmData, R, firCoeffs) {
  // This function forms a simple FIR over the bitstream and then downsamples by R.
  // It's a straightforward approach but not optimized.
  const nBits = pdmData.length * 8;
  const outLen = Math.floor(nBits / R);
  const out = new Float32Array(outLen);
  const L = firCoeffs.length;
  let idx = 0;

  for (let i = 0; i < nBits; i += R) {
    // compute FIR centered/anchored at i (simple causal FIR using previous samples)
    let sum = 0;
    for (let t = 0; t < L; t++) {
      const bitIdx = i - t;
      if (bitIdx < 0) break;
      const x = pdmBitSigned(pdmData, bitIdx);
      sum += x * firCoeffs[t];
    }
    out[idx++] = sum;
  }

  normalizeToFloat32(out);
  return out;
}

// ---------- Small helper: apply FIR on already-decimated PCM (useful for CIC+FIR compensation) ----------
function decimFIR_fromPCM(pcmArray, downsampleFactor=1, firCoeffs=FIR_COEFFS_EXAMPLE) {
  // pcmArray is Float32Array (already decimated samples if downsampleFactor===1)
  const n = pcmArray.length;
  const L = firCoeffs.length;
  const out = new Float32Array(n);
  for (let i = 0; i < n; i++) {
    let acc = 0;
    for (let k = 0; k < L; k++) {
      const idx = i - k;
      if (idx < 0) break;
      acc += pcmArray[idx] * firCoeffs[k];
    }
    out[i] = acc;
  }
  normalizeToFloat32(out);
  return out;
}

// ------------------- Playback (section #4) -------------------
let audioCtx = null;
let sourceNode = null;

async function handlePlayback() {
    const fileInput = document.getElementById('playbackFile');
    if(!fileInput.files.length){ setStatus('Select a file to play', true); return; }
    const file = fileInput.files[0];
    const ext = file.name.split('.').pop().toLowerCase();

    if(!audioCtx) audioCtx = new (window.AudioContext||window.webkitAudioContext)();

    setStatus('Loading file...');
    const ab = await file.arrayBuffer();

    if(ext === 'wav') {
        const audioBuffer = await audioCtx.decodeAudioData(ab.slice(0));
        playAudioBuffer(audioBuffer);
    } else if(ext === 'pdm' || ext === 'bin') {
        // For raw PDM: use current UI decimation settings
        const R = parseInt(document.getElementById('decimationFactor').value||64);
        const algo = document.getElementById('decimationAlgo').value;
        const inRate = parseFloat(document.getElementById('inputPdmRate').value||3076864);
        const pdmData = new Uint8Array(ab);
        setStatus('Decimating PDM for playback...');
        const pcm = decimatePDM(pdmData, R, algo); // Float32Array [-1..1]
        const pcmRate = Math.max(8000, Math.floor(inRate / R));
        const audioBuffer = audioCtx.createBuffer(1, pcm.length, pcmRate);
        audioBuffer.getChannelData(0).set(pcm);
        playAudioBuffer(audioBuffer);
    } else {
        setStatus('Unsupported file type', true);
    }
}

function playAudioBuffer(audioBuffer) {
    stopPlayback();
    sourceNode = audioCtx.createBufferSource();
    sourceNode.buffer = audioBuffer;
    sourceNode.connect(audioCtx.destination);
    sourceNode.start();
    setStatus('Playing...');
}

function stopPlayback() {
    if(sourceNode){ try{ sourceNode.stop(); }catch(e){}; sourceNode.disconnect(); sourceNode = null; }
    setStatus('Playback stopped');
}

// ------------------- WAV encoding -------------------
function encodeWavMonoStereo(pcm, rate, bitDepth){
  const isFloat=(bitDepth===32);
  const bytesPerSample=isFloat?4:Math.ceil(bitDepth/8);
  const nChannels=1; // mono for now
  const nSamples=pcm.length;
  const buffer=new ArrayBuffer(44+nSamples*bytesPerSample*nChannels);
  const view=new DataView(buffer);

  // WAV header
  let offset=0;
  function writeString(s){ for(let i=0;i<s.length;i++) view.setUint8(offset++,s.charCodeAt(i)); }
  writeString('RIFF'); view.setUint32(offset,36+nSamples*bytesPerSample*nChannels,true); offset+=4;
  writeString('WAVE'); writeString('fmt '); view.setUint32(offset,16,true); offset+=4;
  view.setUint16(offset,isFloat?3:1,true); offset+=2; // PCM or float
  view.setUint16(offset,nChannels,true); offset+=2;
  view.setUint32(offset,rate,true); offset+=4;
  view.setUint32(offset,rate*nChannels*bytesPerSample,true); offset+=4;
  view.setUint16(offset,nChannels*bytesPerSample,true); offset+=2;
  view.setUint16(offset,bitDepth,true); offset+=2;
  writeString('data'); view.setUint32(offset,nSamples*bytesPerSample*nChannels,true); offset+=4;

  for(let i=0;i<nSamples;i++){
    let v=Math.max(-1,Math.min(1,pcm[i]));
    if(isFloat) view.setFloat32(offset,v,true);
    else if(bitDepth===8) view.setUint8(offset,Math.round((v+1)*127.5));
    else if(bitDepth===16) view.setInt16(offset,Math.round(v*32767),true);
    else if(bitDepth===24){
      let s=Math.round(v*8388607);
      view.setUint8(offset,s & 0xFF);
      view.setUint8(offset+1,(s>>8)&0xFF);
      view.setUint8(offset+2,(s>>16)&0xFF);
    }
    offset+=bytesPerSample;
  }
  return buffer;
}

// ------------------- Plots -------------------
function drawTimeDomain(data){
    const canvas=document.getElementById('timeCanvas');
    const ctx=canvas.getContext('2d');
    ctx.clearRect(0,0,canvas.width,canvas.height);

    const padding = 40;
    const w = canvas.width - 2*padding;
    const h = canvas.height - 2*padding;

    // Draw waveform
    ctx.strokeStyle='#06b6d4';
    ctx.beginPath();
    for(let i=0;i<data.length;i++){
        const x = padding + i*(w/data.length);
        const y = padding + h*(0.5 - data[i]*0.5);
        if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
    }
    ctx.stroke();

    // Axes
    ctx.strokeStyle='#e6eef8';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(padding, padding);
    ctx.lineTo(padding, padding+h);
    ctx.lineTo(padding+w, padding+h);
    ctx.stroke();

    // Y-axis labels
    ctx.fillStyle='#e6eef8';
    ctx.textAlign='right';
    ctx.textBaseline='middle';
    const yLabels = [-1, -0.5, 0, 0.5, 1];
    for(const yv of yLabels){
        const y = padding + h*(0.5 - yv*0.5);
        ctx.fillText(yv.toFixed(1), padding-5, y);
        ctx.beginPath(); ctx.moveTo(padding-3,y); ctx.lineTo(padding, y); ctx.stroke();
    }

    // X-axis labels (reduce overlap)
    ctx.textAlign='center';
    ctx.textBaseline='top';
    const nTicks = Math.min(10, data.length);
    for(let i=0;i<=nTicks;i++){
        const x = padding + i*(w/nTicks);
        const t = (i*(data.length)/nTicks / 44100).toFixed(3); // adjust sample rate
        ctx.fillText(t, x, padding+h+5);
        ctx.beginPath(); ctx.moveTo(x, padding+h); ctx.lineTo(x, padding+h+3); ctx.stroke();
    }

    // Axis titles
    ctx.save(); ctx.translate(padding-30, padding+h/2); ctx.rotate(-Math.PI/2); ctx.fillText('Amplitude',0,0); ctx.restore();
    ctx.fillText('Time (s)', padding+w/2, padding+h+25);
}

function drawTimeDomain(data){
    const canvas=document.getElementById('timeCanvas');
    const ctx=canvas.getContext('2d');
    ctx.clearRect(0,0,canvas.width,canvas.height);

    const padding = 40;
    const w = canvas.width - 2*padding;
    const h = canvas.height - 2*padding;

    // Draw waveform
    ctx.strokeStyle='#06b6d4';
    ctx.beginPath();
    for(let i=0;i<data.length;i++){
        const x = padding + i*(w/data.length);
        const y = padding + h*(0.5 - data[i]*0.5);
        if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
    }
    ctx.stroke();

    // Axes
    ctx.strokeStyle='#e6eef8';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(padding, padding);
    ctx.lineTo(padding, padding+h);
    ctx.lineTo(padding+w, padding+h);
    ctx.stroke();

    // Y-axis labels
    ctx.fillStyle='#e6eef8';
    ctx.textAlign='right';
    ctx.textBaseline='middle';
    const yLabels = [-1, -0.5, 0, 0.5, 1];
    for(const yv of yLabels){
        const y = padding + h*(0.5 - yv*0.5);
        ctx.fillText(yv.toFixed(1), padding-5, y);
        ctx.beginPath(); ctx.moveTo(padding-3,y); ctx.lineTo(padding, y); ctx.stroke();
    }

    // X-axis labels (reduce overlap)
    ctx.textAlign='center';
    ctx.textBaseline='top';
    const nTicks = Math.min(10, data.length);
    for(let i=0;i<=nTicks;i++){
        const x = padding + i*(w/nTicks);
        const t = (i*(data.length)/nTicks / 44100).toFixed(3); // adjust sample rate
        ctx.fillText(t, x, padding+h+5);
        ctx.beginPath(); ctx.moveTo(x, padding+h); ctx.lineTo(x, padding+h+3); ctx.stroke();
    }

    // Axis titles
    ctx.save(); ctx.translate(padding-30, padding+h/2); ctx.rotate(-Math.PI/2); ctx.fillText('Amplitude',0,0); ctx.restore();
    ctx.fillText('Time (s)', padding+w/2, padding+h+25);
}

function drawFFT(mag, sampleRate=44100){
    const canvas = document.getElementById('fftCanvas');
    const ctx = canvas.getContext('2d');
    ctx.clearRect(0,0,canvas.width,canvas.height);

    const padding = 40;
    const w = canvas.width - 2*padding;
    const h = canvas.height - 2*padding;

    // Draw FFT line
    const maxMag = Math.max(...mag) || 1;
    ctx.strokeStyle='#facc15';
    ctx.beginPath();
    for(let i=0;i<mag.length;i++){
        const x = padding + i*(w/mag.length);
        const y = padding + h*(1 - mag[i]/maxMag);
        if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
    }
    ctx.stroke();

    // Axes
    ctx.strokeStyle='#e6eef8'; ctx.lineWidth=1;
    ctx.beginPath();
    ctx.moveTo(padding, padding); ctx.lineTo(padding, padding+h);
    ctx.lineTo(padding+w, padding+h); ctx.stroke();

    // Y-axis labels
    ctx.fillStyle='#e6eef8'; ctx.textAlign='right'; ctx.textBaseline='middle';
    const yLabels = [0, 0.1, 0.2, 0.3, 0.4, 0.5];
    for(const yv of yLabels){
        const y = padding + h*(1 - yv/Math.max(...yLabels));
        ctx.fillText(yv.toFixed(2), padding-5, y);
        ctx.beginPath(); ctx.moveTo(padding-3,y); ctx.lineTo(padding, y); ctx.stroke();
    }

    // X-axis labels (evenly spaced)
    ctx.textAlign='center'; ctx.textBaseline='top';
    const nTicks = 8; // fewer ticks
    for(let i=0;i<=nTicks;i++){
        const idx = Math.round(i * (mag.length-1) / nTicks);
        const f = Math.round(idx * sampleRate / mag.length); // plain Hz
        const x = padding + i*(w/nTicks);
        ctx.fillText(f.toString(), x, padding+h+5);
        ctx.beginPath(); ctx.moveTo(x, padding+h); ctx.lineTo(x, padding+h+3); ctx.stroke();
    }

    // Axis titles
    ctx.save(); ctx.translate(padding-30, padding+h/2); ctx.rotate(-Math.PI/2); ctx.fillText('Magnitude',0,0); ctx.restore();
    ctx.fillText('Frequency (Hz)', padding+w/2, padding+h+25);
}


function computeMagnitude(data){
  const N=data.length;
  const out=new Float32Array(N/2);
  for(let k=0;k<N/2;k++){
    let re=0,im=0;
    for(let n=0;n<N;n++){ const phi=2*Math.PI*k*n/N; re+=data[n]*Math.cos(phi); im-=data[n]*Math.sin(phi); }
    out[k]=Math.sqrt(re*re+im*im)/N;
  }
  return out;
}

</script>
</body>
</html>

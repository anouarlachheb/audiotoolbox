<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PDM & WAV Signal Processing Toolbox</title>
    <!-- Load Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Custom font and base styling */
        body {
            font-family: 'Inter', sans-serif;
            background-color: #111827; /* Dark background */
        }
        /* Custom scrollbar for better visual on dark mode */
        ::-webkit-scrollbar {
            width: 8px;
        }
        ::-webkit-scrollbar-thumb {
            background: #4b5563;
            border-radius: 4px;
        }
        .section-card {
            background-color: #1f2937;
            border: 1px solid #374151;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }
        /* Custom spinner for loading states */
        .spinner {
            border: 4px solid rgba(255, 255, 255, 0.1);
            border-top: 4px solid #6366f1; /* Indigo */
            border-radius: 50%;
            width: 1.5rem;
            height: 1.5rem;
            animation: spin 1s linear infinite;
            display: none;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        /* Style for the canvas container to enable relative positioning for labels */
        #plot-container {
            position: relative;
        }
    </style>
</head>
<body class="p-4 md:p-8 text-gray-100 min-h-screen">

    <header class="text-center mb-8">
        <h1 class="text-4xl md:text-5xl font-extrabold text-indigo-400 mb-2">PDM & WAV Processing Toolbox</h1>
        <p class="text-gray-400">Sigma-Delta Modulation, Decimation, and Audio Conversion Utilities</p>
    </header>

    <!-- Status and Error Message Area -->
    <div id="status-message" class="mb-6 p-3 rounded-lg text-center font-medium transition-all" style="display: none;"></div>

    <main class="grid grid-cols-1 lg:grid-cols-3 gap-6">

        <!-- SECTION 1: Generate PDM Binary & Visualize Signal -->
        <section class="lg:col-span-2 section-card p-6 rounded-xl space-y-4">
            <h2 class="text-2xl font-semibold border-b border-indigo-500/50 pb-2 text-indigo-300">1. Generate PDM Binary & Visualize Signal</h2>

            <!-- Signal Type and Generation Controls -->
            <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                <div>
                    <label for="signalType" class="block text-sm font-medium text-gray-400">Source Signal</label>
                    <select id="signalType" onchange="toggleSignalInputs()" class="mt-1 block w-full rounded-lg bg-gray-700 border-gray-600 text-white p-2.5 focus:ring-indigo-500 focus:border-indigo-500">
                        <option value="sine">Synthetic Sine Wave</option>
                        <option value="square">Synthetic Square Wave</option>
                        <option value="sawtooth">Synthetic Sawtooth Wave</option>
                        <option value="noise">Synthetic White Noise</option>
                        <option value="mic">Live Microphone Input</option>
                    </select>
                </div>

                <div id="synthetic-controls" class="grid grid-cols-3 gap-2">
                    <div>
                        <label for="signalFrequency" class="block text-sm font-medium text-gray-400">Freq (Hz)</label>
                        <input type="number" id="signalFrequency" value="440" min="1" class="mt-1 block w-full rounded-lg bg-gray-700 border-gray-600 text-white p-2.5 focus:ring-indigo-500 focus:border-indigo-500">
                    </div>
                    <!-- NEW Amplitude Input -->
                    <div>
                        <label for="signalAmplitude" class="block text-sm font-medium text-gray-400">Amp (0-1)</label>
                        <input type="number" id="signalAmplitude" value="0.5" min="0.01" max="1.0" step="0.01" class="mt-1 block w-full rounded-lg bg-gray-700 border-gray-600 text-white p-2.5 focus:ring-indigo-500 focus:border-indigo-500">
                    </div>
                    <!-- NEW Phase Input (in radians) -->
                    <div>
                        <label for="signalPhase" class="block text-sm font-medium text-gray-400">Phase (rad)</label>
                        <input type="number" id="signalPhase" value="0" step="0.1" class="mt-1 block w-full rounded-lg bg-gray-700 border-gray-600 text-white p-2.5 focus:ring-indigo-500 focus:border-indigo-500">
                    </div>
                </div>
            </div>

            <!-- Global PDM Controls -->
            <div class="grid grid-cols-1 md:grid-cols-3 gap-4">
                <div>
                    <label for="pdmRate" class="block text-sm font-medium text-gray-400">Target PDM Sample Rate (Hz)</label>
                    <input type="number" id="pdmRate" value="3072000" min="1" step="1000" class="mt-1 block w-full rounded-lg bg-gray-700 border-gray-600 text-white p-2.5 focus:ring-indigo-500 focus:border-indigo-500">
                </div>
                <div id="duration-control">
                    <label for="duration" class="block text-sm font-medium text-gray-400">Duration (seconds)</label>
                    <input type="number" id="duration" value="0.1" min="0.001" step="0.1" class="mt-1 block w-full rounded-lg bg-gray-700 border-gray-600 text-white p-2.5 focus:ring-indigo-500 focus:border-indigo-500">
                </div>
                 <div>
                    <label for="plotSampleLimit" class="block text-sm font-medium text-gray-400">Plot Samples Limit</label>
                    <input type="number" id="plotSampleLimit" value="2000" min="10" step="10" class="mt-1 block w-full rounded-lg bg-gray-700 border-gray-600 text-white p-2.5 focus:ring-indigo-500 focus:border-indigo-500">
                </div>
            </div>

            <!-- Action Buttons and Mic Status -->
            <div class="flex flex-col sm:flex-row gap-4 pt-2">
                <button onclick="handleGeneratePDM()" id="generateBtn" class="flex-1 bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-2 px-4 rounded-lg transition duration-150 shadow-md shadow-indigo-500/50 flex justify-center items-center">
                    <span id="generateBtnText">Generate & Convert to PDM</span>
                    <div id="spinner1" class="spinner ml-3"></div>
                </button>
                <button onclick="stopRecording(true)" id="stopBtn" class="flex-1 bg-red-600 hover:bg-red-700 text-white font-bold py-2 px-4 rounded-lg transition duration-150 shadow-md shadow-red-500/50" style="display: none;">
                    Stop Recording & Convert PDM
                </button>
            </div>
            
            <!-- Plotting Area -->
            <div class="mt-6">
                <h3 class="text-xl font-semibold mb-2 text-indigo-300">Source Signal Visualization (First N Samples)</h3>
                <p id="plotInfo" class="text-sm text-gray-500 mb-2"></p>
                <div id="plot-container" class="bg-gray-800 rounded-lg border border-gray-700 p-2">
                    <canvas id="signalPlot" class="w-full"></canvas>
                </div>
            </div>

        </section>

        <!-- Right Column (WAV/PDM File Operations) -->
        <div class="lg:col-span-1 space-y-6">

             <!-- SECTION 2: PDM Binary to WAV -->
            <section class="section-card p-6 rounded-xl space-y-4">
                <h2 class="text-2xl font-semibold border-b border-indigo-500/50 pb-2 text-indigo-300">2. PDM Binary to WAV (Decimation)</h2>
                
                <div>
                    <label for="pdmBinaryFile" class="block text-sm font-medium text-gray-400">Upload PDM Binary (.bin) File</label>
                    <input type="file" id="pdmBinaryFile" accept=".bin" class="mt-1 block w-full text-sm text-gray-300 file:mr-4 file:py-2 file:px-4 file:rounded-lg file:border-0 file:text-sm file:font-semibold file:bg-indigo-500 file:text-white hover:file:bg-indigo-600 transition duration-150">
                </div>

                <div class="grid grid-cols-2 gap-4">
                    <div>
                        <label for="decimationFactor" class="block text-sm font-medium text-gray-400">Decimation Factor (R)</label>
                        <input type="number" id="decimationFactor" value="64" min="1" class="mt-1 block w-full rounded-lg bg-gray-700 border-gray-600 text-white p-2.5 focus:ring-indigo-500 focus:border-indigo-500">
                    </div>
                    <div>
                        <label for="originalPDMrate" class="block text-sm font-medium text-gray-400">Original PDM Rate (Hz)</label>
                        <input type="number" id="originalPDMrate" value="3072000" min="1" step="1000" class="mt-1 block w-full rounded-lg bg-gray-700 border-gray-600 text-white p-2.5 focus:ring-indigo-500 focus:border-indigo-500">
                    </div>
                </div>

                <!-- NEW: Decimation Filter Type -->
                <div>
                    <label for="decimationFilterType" class="block text-sm font-medium text-gray-400">Decimation Filter Type</label>
                    <select id="decimationFilterType" class="mt-1 block w-full rounded-lg bg-gray-700 border-gray-600 text-white p-2.5 focus:ring-indigo-500 focus:border-indigo-500">
                        <option value="boxcar">Boxcar/Sinc (1st Order Simplicity)</option>
                        <option value="linear_phase_fir">Linear Phase FIR (Placeholder for Quality)</option>
                        <option value="bypass_pcm_downsample">Bypass (Simple Downsample)</option>
                    </select>
                </div>
                <!-- END NEW -->

                 <div>
                    <label for="pcmBitDepth" class="block text-sm font-medium text-gray-400">PCM Output Bit Depth</label>
                    <select id="pcmBitDepth" class="mt-1 block w-full rounded-lg bg-gray-700 border-gray-600 text-white p-2.5 focus:ring-indigo-500 focus:border-indigo-500">
                        <option value="16">16-bit Integer (Standard)</option>
                        <option value="24">24-bit Integer</option>
                        <option value="32F">32-bit Float</option>
                        <option value="8">8-bit Integer (Unsigned)</option>
                    </select>
                </div>

                <button onclick="pdmBinaryToWav()" class="w-full bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-4 rounded-lg transition duration-150 shadow-md shadow-green-500/50 flex justify-center items-center">
                    <span id="pdmToWavBtnText">Convert to WAV</span>
                     <div id="spinner2" class="spinner ml-3"></div>
                </button>
            </section>

             <!-- SECTION 3: WAV (PCM) to PDM -->
            <section class="section-card p-6 rounded-xl space-y-4">
                <h2 class="text-2xl font-semibold border-b border-indigo-500/50 pb-2 text-indigo-300">3. WAV (PCM) to PDM</h2>
                
                <div>
                    <label for="wavToPdmFile" class="block text-sm font-medium text-gray-400">Upload WAV File (.wav)</label>
                    <input type="file" id="wavToPdmFile" accept=".wav" class="mt-1 block w-full text-sm text-gray-300 file:mr-4 file:py-2 file:px-4 file:rounded-lg file:border-0 file:text-sm file:font-semibold file:bg-indigo-500 file:text-white hover:file:bg-indigo-600 transition duration-150">
                </div>

                <div class="grid grid-cols-2 gap-4">
                    <div>
                        <label for="oversamplingRatio" class="block text-sm font-medium text-gray-400">Oversampling Ratio (OSR)</label>
                        <input type="number" id="oversamplingRatio" value="64" min="1" class="mt-1 block w-full rounded-lg bg-gray-700 border-gray-600 text-white p-2.5 focus:ring-indigo-500 focus:border-indigo-500">
                    </div>
                    <!-- UPDATED: Oversampling Filter Type with explicit Bypass label -->
                    <div>
                        <label for="oversamplingFilterType" class="block text-sm font-medium text-gray-400">Oversampling Filter Type</label>
                        <select id="oversamplingFilterType" class="mt-1 block w-full rounded-lg bg-gray-700 border-gray-600 text-white p-2.5 focus:ring-indigo-500 focus:border-indigo-500">
                            <option value="nearest_neighbor">Bypass (Nearest Neighbor / ZOH)</option>
                            <option value="linear_interpolation">Linear Interpolation</option>
                        </select>
                    </div>
                    <!-- END UPDATED -->
                </div>

                <button onclick="wavToPdm()" class="w-full bg-yellow-600 hover:bg-yellow-700 text-white font-bold py-2 px-4 rounded-lg transition duration-150 shadow-md shadow-yellow-500/50 flex justify-center items-center">
                    <span id="wavToPdmBtnText">Convert to PDM</span>
                    <div id="spinner3" class="spinner ml-3"></div>
                </button>
            </section>
        </div>

    </main>
    
    <script>
        // --- Global State and Constants ---
        let audioContext = null;
        let mediaStream = null;
        let recorder = null;
        let recordingBuffer = null;
        const RESAMPLE_RATE = 48000; // Fixed rate for synthetic signal generation

        // --- Utility Functions ---

        /** Sets the status message with color coding for success/error. */
        function setStatus(message, isError = false) {
            const statusDiv = document.getElementById('status-message');
            statusDiv.textContent = message;
            statusDiv.style.display = 'block';
            if (isError) {
                statusDiv.className = 'mb-6 p-3 rounded-lg text-center font-medium bg-red-900/50 text-red-300 transition-all';
            } else {
                statusDiv.className = 'mb-6 p-3 rounded-lg text-center font-medium bg-indigo-900/50 text-indigo-300 transition-all';
            }
        }
        
        /** Shows or hides a spinner element. */
        function toggleSpinner(id, show) {
            const spinner = document.getElementById(id);
            const buttonText = spinner.previousElementSibling;
            if (show) {
                spinner.style.display = 'block';
                buttonText.classList.add('opacity-0');
            } else {
                spinner.style.display = 'none';
                buttonText.classList.remove('opacity-0');
            }
        }

        /** Creates a data URI link to download a file. */
        function downloadFile(data, mimeType, filename) {
            const blob = new Blob([data], { type: mimeType });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        /** Simple 1st-order Sigma-Delta Modulator (SDM) / Noise Shaper */
        function sigmaDeltaModulation(pcmData, osr) {
            const M = osr;
            const N = pcmData.length;
            const pdmLength = N * M;
            const pdmArray = new Uint8Array(pdmLength);
            let accumulator = 0;

            for (let i = 0; i < N; i++) {
                const pcmSample = pcmData[i]; // PCM sample is normalized between -1.0 and 1.0

                // Resample (Zero-order hold for simplicity) and modulate
                for (let j = 0; j < M; j++) {
                    // Integrator input (error signal)
                    const input = pcmSample - accumulator;
                    
                    // Comparator / Quantizer: Determine the PDM bit (1 or 0)
                    let outputBit = 0;
                    if (input > 0) {
                        outputBit = 1;
                    } 
                    
                    // Quantization error
                    const error = outputBit - pcmSample;
                    
                    // Integrator update (1st order)
                    accumulator += error; 

                    // Store PDM bit (0 or 1)
                    pdmArray[i * M + j] = outputBit; 
                }
            }
            return pdmArray;
        }

        /** Converts the PDM bit stream into a packed binary stream (8 bits per byte). */
        function packPDM(pdmBits) {
            const packedLength = Math.ceil(pdmBits.length / 8);
            const packedArray = new Uint8Array(packedLength);

            for (let i = 0; i < pdmBits.length; i++) {
                const byteIndex = Math.floor(i / 8);
                const bitPosition = 7 - (i % 8); // Store MSB first in the byte
                
                if (pdmBits[i] === 1) {
                    packedArray[byteIndex] |= (1 << bitPosition);
                }
            }
            return packedArray;
        }

        /** Generates a synthetic signal (PCM format, -1.0 to 1.0). */
        function generateSyntheticSignal(rate, duration, type, frequency, amplitude, phase) {
            const numSamples = Math.floor(rate * duration);
            const data = new Float32Array(numSamples);
            const A = parseFloat(amplitude);
            const F = parseFloat(frequency);
            const P = parseFloat(phase);

            if (type === 'noise') {
                for (let i = 0; i < numSamples; i++) {
                    // White noise, normalized to +/- amplitude
                    data[i] = (Math.random() * 2 - 1) * A;
                }
            } else {
                for (let i = 0; i < numSamples; i++) {
                    const t = i / rate;
                    const normalizedTime = 2 * Math.PI * F * t + P;

                    switch (type) {
                        case 'sine':
                            data[i] = A * Math.sin(normalizedTime);
                            break;
                        case 'square':
                            // Simple square wave approximation (sign function)
                            data[i] = A * (Math.sign(Math.sin(normalizedTime)) || 0);
                            break;
                        case 'sawtooth':
                            // Simple sawtooth wave
                            data[i] = A * (2 * ((normalizedTime / (2 * Math.PI)) % 1) - 1);
                            break;
                        default:
                            data[i] = 0;
                    }
                }
            }
            return data;
        }

        /**
         * Resamples PCM data from sourceRate to targetRate using selected interpolation/filtering.
         * Note: For real-world use, a proper polyphase FIR filter should be used.
         */
        function resamplePCM(sourceData, sourceRate, targetRate, filterType = 'nearest_neighbor') {
            if (sourceRate === targetRate) {
                return sourceData;
            }

            const ratio = sourceRate / targetRate;
            const targetLength = Math.floor(sourceData.length / ratio);
            const targetData = new Float32Array(targetLength);

            for (let i = 0; i < targetLength; i++) {
                const sourceIndexFloat = i * ratio;
                let sample;

                if (filterType === 'linear_interpolation') {
                    // Linear Interpolation
                    const index1 = Math.floor(sourceIndexFloat);
                    const index2 = Math.min(index1 + 1, sourceData.length - 1);
                    const fraction = sourceIndexFloat - index1;

                    const val1 = sourceData[index1];
                    const val2 = sourceData[index2];
                    
                    // Linear interpolation: y = y1 + fraction * (y2 - y1)
                    sample = val1 + fraction * (val2 - val1);

                } else { // default to 'nearest_neighbor' (Bypass / ZOH)
                    // Nearest Neighbor Interpolation (Zero-Order Hold)
                    const sourceIndex = Math.min(Math.round(sourceIndexFloat), sourceData.length - 1);
                    sample = sourceData[sourceIndex];
                }
                
                targetData[i] = sample;
            }
            return targetData;
        }


        // --- Plotting Logic (Canvas) ---

        /** Draws the given PCM signal data on the canvas. */
        function plotSignal(data, rate, isPDM = false) {
            const canvas = document.getElementById('signalPlot');
            const ctx = canvas.getContext('2d');
            
            // Set canvas size based on container for responsiveness (Tailwind `w-full`)
            const container = document.getElementById('plot-container');
            canvas.width = container.clientWidth;
            canvas.height = 300; 

            const width = canvas.width;
            const height = canvas.height;
            const plotLimit = parseInt(document.getElementById('plotSampleLimit').value, 10);
            
            // Determine the data to plot (limited by plotLimit)
            const plotData = data.slice(0, plotLimit);
            const dataLength = plotData.length;
            
            const infoDiv = document.getElementById('plotInfo');
            if (dataLength === 0) {
                 infoDiv.textContent = "No signal data to plot.";
                 ctx.clearRect(0, 0, width, height);
                 return;
            } else {
                 const timeSpan = (dataLength / rate) * 1000; // in milliseconds
                 infoDiv.textContent = isPDM 
                    ? `PDM Bits: ${dataLength} plotted over ${timeSpan.toFixed(2)}ms (PDM Rate: ${rate.toLocaleString()} Hz)`
                    : `PCM Samples: ${dataLength} plotted over ${timeSpan.toFixed(2)}ms (PCM Rate: ${rate.toLocaleString()} Hz)`;
            }

            ctx.clearRect(0, 0, width, height);

            // Draw background and axes
            ctx.fillStyle = '#1f2937'; // Background color from section-card
            ctx.fillRect(0, 0, width, height);

            ctx.strokeStyle = '#374151'; // Axis color
            ctx.lineWidth = 1;
            
            // Center line (Y=0)
            const center = height / 2;
            ctx.beginPath();
            ctx.moveTo(0, center);
            ctx.lineTo(width, center);
            ctx.stroke();
            
            // 1.0 and -1.0 lines
            ctx.strokeStyle = '#4b5563'; 
            ctx.setLineDash([5, 5]);
            ctx.beginPath();
            ctx.moveTo(0, height * 0.1);
            ctx.lineTo(width, height * 0.1);
            ctx.moveTo(0, height * 0.9);
            ctx.lineTo(width, height * 0.9);
            ctx.stroke();
            ctx.setLineDash([]);


            // Draw the signal
            ctx.beginPath();
            ctx.strokeStyle = '#6366f1'; // Signal color (Indigo)
            ctx.lineWidth = isPDM ? 0.5 : 2; // Thicker line for PCM, thin for PDM
            
            const stepX = width / dataLength;

            for (let i = 0; i < dataLength; i++) {
                const x = i * stepX;
                let y;

                if (isPDM) {
                    // PDM is 0 or 1, map to -1.0 to 1.0 range for visual
                    const bit = plotData[i];
                    // Map 0 to bottom (0.9H) and 1 to top (0.1H)
                    y = height * (1 - bit * 0.8 - 0.1); // 0 -> 0.9H, 1 -> 0.1H
                } else {
                    // PCM is -1.0 to 1.0
                    const sample = plotData[i];
                    // Map -1.0 to bottom (0.9H) and 1.0 to top (0.1H)
                    y = center - (sample * center * 0.8); 
                }

                if (i === 0) {
                    ctx.moveTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }
            }
            ctx.stroke();
        }

        // --- Core PDM/PCM Conversion Functions ---

        /** Generic function to handle PCM to PDM conversion and file download. */
        async function convertPCMToPDM(pcmData, pcmRate, filenamePrefix = 'pdm_output') {
             // Calculate OSR based on target PDM rate and source PCM rate
            const targetPDMrate = parseInt(document.getElementById('pdmRate').value, 10);
            const oversamplingFilterType = document.getElementById('oversamplingFilterType')?.value || 'nearest_neighbor';

            const OSR = Math.round(targetPDMrate / pcmRate);
            
            if (OSR < 1) {
                setStatus(`PDM rate (${targetPDMrate} Hz) must be greater than or equal to the source PCM rate (${pcmRate} Hz).`, true);
                return;
            }

            setStatus(`Processing... Resampling PCM to ${targetPDMrate} Hz equivalent PCM (OSR=${OSR}) using ${oversamplingFilterType}.`);

            // 1. Resample PCM data to a higher rate (OSR * PCM Rate)
            const resampledData = resamplePCM(pcmData, pcmRate, targetPDMrate, oversamplingFilterType);
            
            // 2. Perform Sigma-Delta Modulation (PDM generation)
            setStatus(`Processing... Performing 1st-order Sigma-Delta Modulation.`);
            const pdmBits = sigmaDeltaModulation(resampledData, 1); // OSR is handled by resampling
            
            // 3. Pack PDM bits into bytes
            setStatus(`Processing... Packing PDM bits into binary stream.`);
            const pdmBinary = packPDM(pdmBits);

            // 4. Download files
            downloadFile(pdmBinary, 'application/octet-stream', `${filenamePrefix}_OSR${OSR}.bin`);
            setStatus(`PDM Binary File saved: ${filenamePrefix}_OSR${OSR}.bin (Size: ${pdmBinary.byteLength} bytes).`);

            // 5. Plot the original PCM signal
            // Plot the original PCM data (or the raw mic data if available)
            plotSignal(pcmData, pcmRate, false);
            
            return pdmBinary;
        }

        /** Handles synthetic signal generation and Mic setup. */
        async function handleGeneratePDM() {
            const signalType = document.getElementById('signalType').value;
            toggleSpinner('spinner1', true);
            setStatus('Starting signal processing...');

            try {
                if (signalType === 'mic') {
                    await startRecording();
                } else {
                    const F = document.getElementById('signalFrequency').value;
                    const A = document.getElementById('signalAmplitude').value;
                    const P = document.getElementById('signalPhase').value;
                    const duration = parseFloat(document.getElementById('duration').value);
                    
                    if (duration <= 0) {
                         setStatus("Duration must be a positive number.", true);
                         toggleSpinner('spinner1', false);
                         return;
                    }

                    // 1. Generate Synthetic PCM signal (at a fixed RESAMPLE_RATE)
                    const pcmData = generateSyntheticSignal(RESAMPLE_RATE, duration, signalType, F, A, P);
                    
                    // 2. Convert PCM to PDM and save/plot
                    await convertPCMToPDM(pcmData, RESAMPLE_RATE, `synth_${signalType}`);
                }
            } catch (error) {
                setStatus(`An error occurred: ${error.message}`, true);
                toggleSpinner('spinner1', false);
            } finally {
                if (signalType !== 'mic') {
                    toggleSpinner('spinner1', false);
                }
            }
        }

        /** Handles PDM Binary upload and conversion to WAV (Decimation). */
        async function pdmBinaryToWav() {
            const fileInput = document.getElementById('pdmBinaryFile');
            const decimationFactor = parseInt(document.getElementById('decimationFactor').value, 10);
            const originalPDMrate = parseInt(document.getElementById('originalPDMrate').value, 10);
            const pcmBitDepth = document.getElementById('pcmBitDepth').value;
            const decimationFilterType = document.getElementById('decimationFilterType').value;

            if (!fileInput.files.length) {
                setStatus("Please upload a PDM Binary (.bin) file.", true);
                return;
            }

            if (decimationFactor <= 0 || originalPDMrate <= 0) {
                 setStatus("Decimation Factor and Original PDM Rate must be positive numbers.", true);
                 return;
            }
            
            toggleSpinner('spinner2', true);
            setStatus(`Converting PDM to WAV (R=${decimationFactor}, PDM Rate=${originalPDMrate} Hz) using ${decimationFilterType}...`);

            try {
                const pdmArrayBuffer = await fileInput.files[0].arrayBuffer();
                const pdmBinary = new Uint8Array(pdmArrayBuffer);
                
                // 1. Unpack PDM data to a bit array
                const pdmBits = unpackPDM(pdmBinary);

                // 2. Perform Decimation (using selected filter)
                const pcmData = decimatePDM(pdmBits, decimationFactor, decimationFilterType);
                const pcmRate = originalPDMrate / decimationFactor;
                
                setStatus(`Conversion successful. Output PCM Rate: ${pcmRate.toLocaleString()} Hz.`);
                
                // 3. Write WAV header and data
                const wavBuffer = encodeWAV(pcmData, pcmRate, pcmBitDepth);

                // 4. Download file
                downloadFile(wavBuffer, 'audio/wav', `decimated_R${decimationFactor}_${originalPDMrate/decimationFactor}Hz.wav`);
                setStatus(`WAV file saved successfully! (Rate: ${pcmRate} Hz, Depth: ${pcmBitDepth})`);

                // 5. Plot the PDM bit stream (before decimation)
                plotSignal(pdmBits, originalPDMrate, true);

            } catch (error) {
                setStatus(`Error during PDM to WAV conversion: ${error.message}`, true);
            }
            toggleSpinner('spinner2', false);
        }
        
        /** Handles WAV (PCM) upload and conversion to PDM. */
        async function wavToPdm() {
            const fileInput = document.getElementById('wavToPdmFile');
            const OSR = parseInt(document.getElementById('oversamplingRatio').value, 10);

            if (!fileInput.files.length) {
                setStatus("Please upload a WAV (.wav) file.", true);
                return;
            }
            if (OSR < 1) {
                 setStatus("Oversampling Ratio (OSR) must be 1 or greater.", true);
                 return;
            }
            
            toggleSpinner('spinner3', true);
            setStatus(`Reading WAV file...`);

            try {
                const wavArrayBuffer = await fileInput.files[0].arrayBuffer();
                
                // 1. Decode WAV to PCM Float32Array
                const { pcmData: decodedData, sampleRate: sourceRate } = decodeWAV(wavArrayBuffer);
                
                // WAV files can have multiple channels, only use the first channel
                const sourceData = decodedData[0];
                const pdmRate = sourceRate * OSR;
                
                document.getElementById('pdmRate').value = pdmRate; // Update PDM Rate box for consistency

                // Use the new general function which handles resampling and conversion
                await convertPCMToPDM(sourceData, sourceRate, `encoded_wav_osr${OSR}`);

            } catch (error) {
                setStatus(`Error during WAV to PDM conversion: ${error.message}`, true);
            }
            toggleSpinner('spinner3', false);
        }

        /** Unpacks the PDM binary stream back into a 0/1 bit array. */
        function unpackPDM(pdmBinary) {
            const totalBits = pdmBinary.length * 8;
            const pdmBits = new Uint8Array(totalBits);
            let bitIndex = 0;

            for (let i = 0; i < pdmBinary.length; i++) {
                const byte = pdmBinary[i];
                for (let j = 7; j >= 0; j--) { // Unpack MSB first (matching the packing order)
                    pdmBits[bitIndex++] = (byte >> j) & 1;
                }
            }
            return pdmBits;
        }

        /** Performs PDM decimation using the selected filter type. */
        function decimatePDM(pdmBits, R, filterType) {
            const numSamples = Math.floor(pdmBits.length / R);
            const pcmData = new Float32Array(numSamples);

            if (filterType === 'bypass_pcm_downsample') {
                // Bypass: Simple downsampling of PDM bits converted to +/-1.0 PCM.
                for (let i = 0; i < numSamples; i++) {
                    const index = i * R;
                    // Map 0 -> -1.0, 1 -> +1.0
                    pcmData[i] = pdmBits[index] * 2.0 - 1.0; 
                }
                return pcmData;
            }

            // Default: Boxcar Filter (Moving Average)
            // 'boxcar' and 'linear_phase_fir' (placeholder) use this simple method.
            for (let i = 0; i < numSamples; i++) {
                let sum = 0;
                const start = i * R;
                const end = start + R;

                // Boxcar filter (simple moving average/integration)
                for (let j = start; j < end; j++) {
                    sum += pdmBits[j];
                }

                // Correct PDM (0/1) accumulated sum ([0, R]) to normalized PCM ([-1.0, 1.0])
                // Output = (sum / R) * 2 - 1
                pcmData[i] = (sum / R) * 2.0 - 1.0;
            }
            
            // Clamping is necessary to ensure the output remains within the valid range
            for (let i = 0; i < pcmData.length; i++) {
                pcmData[i] = Math.max(-1.0, Math.min(1.0, pcmData[i]));
            }

            return pcmData;
        }

        // --- WAV Encoding and Decoding (Minimal Implementation) ---

        /** Encodes normalized Float32Array PCM data into a WAV file ArrayBuffer. */
        function encodeWAV(pcmData, sampleRate, bitDepthType) {
            const numChannels = 1;
            
            // Determine size and format
            let bytesPerSample, format;
            if (bitDepthType === '16') {
                bytesPerSample = 2;
                format = 1; // PCM
            } else if (bitDepthType === '24') {
                bytesPerSample = 3;
                format = 1; // PCM
            } else if (bitDepthType === '32F') {
                bytesPerSample = 4;
                format = 3; // Float
            } else if (bitDepthType === '8') {
                bytesPerSample = 1;
                format = 1; // PCM
            } else {
                throw new Error("Unsupported PCM bit depth type: " + bitDepthType);
            }

            const bitDepth = bytesPerSample * 8;
            const blockAlign = numChannels * bytesPerSample;
            const byteRate = sampleRate * blockAlign;
            const dataLength = pcmData.length * bytesPerSample;
            const buffer = new ArrayBuffer(44 + dataLength);
            const view = new DataView(buffer);
            let offset = 0;

            // Helper function to write a string
            const writeString = (s) => {
                for (let i = 0; i < s.length; i++) {
                    view.setUint8(offset++, s.charCodeAt(i));
                }
            };
            
            // Helper function to write the PCM data
            const writePCMData = () => {
                // Max value for integer scaling (2^n-1)
                const maxVal = Math.pow(2, bitDepth - (format === 1 ? 1 : 0)); 

                for (let i = 0; i < pcmData.length; i++) {
                    let sample = pcmData[i];

                    if (format === 3) { // 32-bit Float
                        view.setFloat32(offset, sample, true);
                        offset += 4;
                    } else { // Integer formats (8, 16, 24)
                        if (bitDepth === 8) { // 8-bit unsigned
                            // Map [-1, 1] to [0, 255]
                            let val = Math.round((sample + 1.0) * 127.5);
                            view.setUint8(offset++, val);
                        } else if (bitDepth === 16) {
                            let val = Math.round(sample * maxVal);
                            view.setInt16(offset, val, true);
                            offset += 2;
                        } else if (bitDepth === 24) {
                            let val = Math.round(sample * maxVal);
                            // Write 24-bit value manually (little-endian)
                            view.setUint8(offset++, val & 0xFF);
                            view.setUint8(offset++, (val >> 8) & 0xFF);
                            view.setUint8(offset++, (val >> 16) & 0xFF);
                        }
                    }
                }
            };

            // RIFF chunk
            writeString('RIFF'); // Chunk ID
            view.setUint32(offset, 36 + dataLength, true); // Chunk Size
            offset += 4;
            writeString('WAVE'); // Format

            // FMT sub-chunk
            writeString('fmt '); // Sub-chunk 1 ID
            view.setUint32(offset, 16, true); // Sub-chunk 1 Size (16 for PCM)
            offset += 4;
            view.setUint16(offset, format, true); // Audio Format (1=PCM, 3=Float)
            offset += 2;
            view.setUint16(offset, numChannels, true); // Num Channels (Mono)
            offset += 2;
            view.setUint32(offset, sampleRate, true); // Sample Rate
            offset += 4;
            view.setUint32(offset, byteRate, true); // Byte Rate
            offset += 4;
            view.setUint16(offset, blockAlign, true); // Block Align
            offset += 2;
            view.setUint16(offset, bitDepth, true); // Bits Per Sample
            offset += 2;

            // DATA sub-chunk
            writeString('data'); // Sub-chunk 2 ID
            view.setUint32(offset, dataLength, true); // Sub-chunk 2 Size
            offset += 4;
            
            writePCMData();

            return buffer;
        }

        /** Decodes a WAV file ArrayBuffer into an array of normalized Float32Arrays (one per channel). */
        function decodeWAV(wavArrayBuffer) {
            const view = new DataView(wavArrayBuffer);
            let offset = 0;

            // Helper to read a string
            const readString = (len) => {
                let s = '';
                for (let i = 0; i < len; i++) {
                    s += String.fromCharCode(view.getUint8(offset++));
                }
                return s;
            };

            // RIFF check
            if (readString(4) !== 'RIFF') throw new Error('Invalid WAV file: missing RIFF tag.');
            view.getUint32(offset, true); // Chunk Size
            offset += 4;
            if (readString(4) !== 'WAVE') throw new Error('Invalid WAV file: missing WAVE tag.');

            // Find FMT chunk
            while (readString(4) !== 'fmt ') {
                const chunkSize = view.getUint32(offset, true);
                offset += 4 + chunkSize;
                if (offset >= wavArrayBuffer.byteLength) throw new Error('WAV file error: fmt chunk not found.');
                offset -= 8; // Backtrack to read chunk ID
                readString(4); // Consume ID again
            }

            const fmtSize = view.getUint32(offset, true);
            offset += 4;
            const audioFormat = view.getUint16(offset, true);
            offset += 2;
            const numChannels = view.getUint16(offset, true);
            offset += 2;
            const sampleRate = view.getUint32(offset, true);
            offset += 4;
            view.getUint32(offset, true); // Byte Rate
            offset += 4;
            view.getUint16(offset, true); // Block Align
            offset += 2;
            const bitDepth = view.getUint16(offset, true);
            offset += 2;
            offset += fmtSize - 16; // Skip any extra format bytes

            // Find DATA chunk
            while (readString(4) !== 'data') {
                const chunkSize = view.getUint32(offset, true);
                offset += 4 + chunkSize;
                if (offset >= wavArrayBuffer.byteLength) throw new Error('WAV file error: data chunk not found.');
                offset -= 8; // Backtrack to read chunk ID
                readString(4); // Consume ID again
            }

            const dataSize = view.getUint32(offset, true);
            offset += 4;

            const bytesPerSample = bitDepth / 8;
            const numSamples = dataSize / (numChannels * bytesPerSample);
            const pcmData = new Array(numChannels).fill(0).map(() => new Float32Array(numSamples));

            // Helper to read a sample and normalize it to [-1.0, 1.0]
            const readSample = () => {
                let sample;
                if (audioFormat === 1) { // PCM Integer
                    if (bitDepth === 8) { // 8-bit unsigned
                        sample = view.getUint8(offset) / 127.5 - 1.0;
                        offset += 1;
                    } else if (bitDepth === 16) {
                        sample = view.getInt16(offset, true) / 32768.0;
                        offset += 2;
                    } else if (bitDepth === 24) { // 24-bit signed
                        let val = (view.getUint8(offset) | (view.getUint8(offset + 1) << 8) | (view.getUint8(offset + 2) << 16));
                        // Sign extend 24-bit
                        if (val & 0x800000) val |= 0xFF000000;
                        sample = val / 8388608.0; // 2^23
                        offset += 3;
                    } else if (bitDepth === 32) { // 32-bit signed
                        sample = view.getInt32(offset, true) / 2147483648.0; // 2^31
                        offset += 4;
                    } else {
                        throw new Error(`Unsupported PCM bit depth: ${bitDepth}`);
                    }
                } else if (audioFormat === 3) { // Float
                    if (bitDepth === 32) {
                        sample = view.getFloat32(offset, true);
                        offset += 4;
                    } else {
                        throw new Error(`Unsupported Float bit depth: ${bitDepth}`);
                    }
                } else {
                    throw new Error(`Unsupported audio format: ${audioFormat}`);
                }
                return sample;
            };

            // Read the actual data
            for (let i = 0; i < numSamples; i++) {
                for (let j = 0; j < numChannels; j++) {
                    pcmData[j][i] = readSample();
                }
            }

            return { pcmData, sampleRate, numChannels };
        }


        // --- Microphone Recording Logic ---

        function toggleSignalInputs() {
            const isMic = document.getElementById('signalType').value === 'mic';
            document.getElementById('synthetic-controls').style.display = isMic ? 'none' : 'grid';
            document.getElementById('duration-control').style.display = isMic ? 'none' : 'block';
            document.getElementById('generateBtnText').textContent = isMic ? 'Start Recording' : 'Generate & Convert to PDM';
            document.getElementById('stopBtn').style.display = 'none'; // Ensure stop is hidden initially
        }

        async function startRecording() {
            if (!audioContext) {
                 // Ensure AudioContext is initialized before accessing mic
                 audioContext = new (window.AudioContext || window.webkitAudioContext)();
            }
            if (audioContext.state === 'suspended') {
                 await audioContext.resume();
            }

            try {
                mediaStream = await navigator.mediaDevices.getUserMedia({ audio: true });
                
                // Create a MediaStreamAudioSourceNode
                const source = audioContext.createMediaStreamSource(mediaStream);
                
                // Create a ScriptProcessorNode (deprecated, but simplest for cross-browser in this context)
                const bufferSize = 4096;
                recorder = audioContext.createScriptProcessor(bufferSize, 1, 1);
                
                recordingBuffer = [];
                
                recorder.onaudioprocess = (e) => {
                    // Get the mono input data
                    const inputData = e.inputBuffer.getChannelData(0);
                    // Copy the data to the recording buffer
                    recordingBuffer.push(new Float32Array(inputData));
                };
                
                // Connect the nodes
                source.connect(recorder);
                recorder.connect(audioContext.destination);

                document.getElementById('generateBtn').style.display = 'none';
                document.getElementById('stopBtn').style.display = 'flex';
                setStatus("Recording live microphone input... Click 'Stop Recording' when finished.", false);

            } catch (err) {
                setStatus(`Could not access microphone: ${err.message}. Please check permissions.`, true);
                toggleSpinner('spinner1', false);
            }
        }

        async function stopRecording(isConversionTriggered) {
            if (mediaStream) {
                mediaStream.getTracks().forEach(track => track.stop());
                mediaStream = null;
            }

            if (recorder) {
                recorder.disconnect();
                recorder = null;
            }
            
            document.getElementById('generateBtn').style.display = 'flex';
            document.getElementById('stopBtn').style.display = 'none';

            if (isConversionTriggered && recordingBuffer && recordingBuffer.length > 0) {
                setStatus("Stopping recording and compiling PCM data...");
                toggleSpinner('spinner1', true);
                
                try {
                    // Combine all buffer segments into one Float32Array
                    const totalLength = recordingBuffer.reduce((acc, arr) => acc + arr.length, 0);
                    const pcmData = new Float32Array(totalLength);
                    let offset = 0;
                    for (const buffer of recordingBuffer) {
                        pcmData.set(buffer, offset);
                        offset += buffer.length;
                    }

                    recordingBuffer = null; // Clear buffer for next recording
                    
                    // The microphone input rate is audioContext.sampleRate
                    const sourceRate = audioContext.sampleRate;
                    
                    // Convert PCM to PDM and save/plot
                    await convertPCMToPDM(pcmData, sourceRate, `mic_recording`);
                
                } catch (error) {
                    setStatus(`Error during mic PCM processing: ${error.message}`, true);
                }
                
                toggleSpinner('spinner1', false);
            } else if (isConversionTriggered) {
                setStatus("Recording stopped. No audio data was captured.", true);
            }
        }


        // --- Initialization ---
        document.addEventListener('DOMContentLoaded', () => {
             // Initialize AudioContext on first user interaction (browser requirement)
            document.addEventListener('click', () => {
                if (!audioContext) {
                    // Start in suspended state
                    audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    // Auto-resume if needed
                    if (audioContext.state === 'suspended') {
                         audioContext.resume();
                    }
                }
            }, { once: true });
            
            toggleSignalInputs(); // Set initial visibility based on default option
            
            // Initial clear plot and information update
            plotSignal(new Float32Array(0), 1); 
            
            // Re-plot on window resize to ensure responsiveness
            window.addEventListener('resize', () => plotSignal(new Float32Array(0), 1));
        });
    </script>
</body>
</html>
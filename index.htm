<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PDM & WAV Signal Processing Toolbox</title>
    <!-- Load Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Custom font and base styling */
        body {
            font-family: 'Inter', sans-serif;
            background-color: #111827; /* Dark background */
        }
        /* Custom scrollbar for better visual on dark mode */
        ::-webkit-scrollbar {
            width: 8px;
        }
        ::-webkit-scrollbar-thumb {
            background: #4b5563;
            border-radius: 4px;
        }
        .section-card {
            background-color: #1f2937;
            border: 1px solid #374151;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }
    </style>
</head>
<body class="p-4 md:p-8 min-h-screen text-gray-100">

    <div class="w-full max-w-6xl mx-auto space-y-8">
        <h1 class="text-4xl font-extrabold text-indigo-400 mb-6 text-center">
            PDM & WAV Processing Toolbox
        </h1>
        <p id="status-message" class="text-center text-lg font-medium h-6"></p>

        <!-- Main Grid Layout -->
        <div class="grid grid-cols-1 lg:grid-cols-3 gap-6">

            <!-- PDM Signal Generation -->
            <div class="section-card rounded-xl p-6 space-y-4">
                <h2 class="text-2xl font-bold text-indigo-300 border-b border-indigo-500/50 pb-2 mb-4">
                    1. Generate PDM Binary
                </h2>
                <div class="space-y-3">
                    <label for="signalType" class="block text-sm font-medium text-gray-300">Signal Type</label>
                    <select id="signalType" class="w-full p-2 rounded-lg bg-gray-700 border border-gray-600 text-white focus:ring-indigo-500 focus:border-indigo-500">
                        <option value="sine">Sine Wave</option>
                        <option value="square">Square Wave</option>
                        <option value="noise">White Noise</option>
                    </select>
                </div>
                <div class="space-y-3">
                    <label for="signalFreq" class="block text-sm font-medium text-gray-300">Signal Frequency (Hz)</label>
                    <input type="number" id="signalFreq" value="1000" min="1" class="w-full p-2 rounded-lg bg-gray-700 border border-gray-600 text-white focus:ring-indigo-500 focus:border-indigo-500">
                </div>
                <div class="space-y-3">
                    <label for="pdmRate" class="block text-sm font-medium text-gray-300">PDM Sample Rate (Hz)</label>
                    <input type="number" id="pdmRate" value="3076864" min="100000" class="w-full p-2 rounded-lg bg-gray-700 border border-gray-600 text-white focus:ring-indigo-500 focus:border-indigo-500">
                </div>
                <div class="space-y-3">
                    <label for="duration" class="block text-sm font-medium text-gray-300">Duration (seconds)</label>
                    <input type="number" id="duration" value="1.0" min="0.1" step="0.1" class="w-full p-2 rounded-lg bg-gray-700 border border-gray-600 text-white focus:ring-indigo-500 focus:border-indigo-500">
                </div>
                <button onclick="handleGeneratePDM()" class="w-full mt-4 bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-3 px-4 rounded-lg transition-all duration-200 focus:outline-none focus:ring-4 focus:ring-indigo-500/50 shadow-md">
                    Generate & Download PDM (.bin)
                </button>
            </div>

            <!-- PDM to WAV Conversion -->
            <div class="section-card rounded-xl p-6 space-y-4">
                <h2 class="text-2xl font-bold text-indigo-300 border-b border-indigo-500/50 pb-2 mb-4">
                    2. PDM Binary to WAV
                </h2>
                <div class="space-y-3">
                    <label for="pdmFile" class="block text-sm font-medium text-gray-300">Upload PDM Binary (.bin)</label>
                    <input type="file" id="pdmFile" accept=".bin, .pdm, application/octet-stream" class="w-full p-2 rounded-lg bg-gray-700 border border-gray-600 text-white focus:ring-indigo-500 focus:border-indigo-500">
                </div>
                <div class="space-y-3">
                    <label for="decimationFactor" class="block text-sm font-medium text-gray-300">Decimation Factor (R)</label>
                    <input type="number" id="decimationFactor" value="64" min="2" step="2" class="w-full p-2 rounded-lg bg-gray-700 border border-gray-600 text-white focus:ring-indigo-500 focus:border-indigo-500">
                    <p class="text-xs text-gray-400">PCM Rate = PDM Rate / R</p>
                </div>
                <div class="space-y-3">
                    <label for="inputPdmRate" class="block text-sm font-medium text-gray-300">Original PDM Rate (Hz)</label>
                    <input type="number" id="inputPdmRate" value="3076864" min="100000" class="w-full p-2 rounded-lg bg-gray-700 border border-gray-600 text-white focus:ring-indigo-500 focus:border-indigo-500">
                </div>
                <!-- NEW BIT DEPTH SELECTION -->
                <div class="space-y-3">
                    <label for="outputBitDepth" class="block text-sm font-medium text-gray-300">PCM Output Bit Depth</label>
                    <select id="outputBitDepth" class="w-full p-2 rounded-lg bg-gray-700 border border-gray-600 text-white focus:ring-indigo-500 focus:border-indigo-500">
                        <option value="16">16-bit Signed Integer (PCM)</option>
                        <option value="32f">32-bit Floating Point (IEEE Float)</option>
                    </select>
                </div>
                <button onclick="handlePdmToWav()" class="w-full mt-4 bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-3 px-4 rounded-lg transition-all duration-200 focus:outline-none focus:ring-4 focus:ring-indigo-500/50 shadow-md">
                    Convert & Download WAV
                </button>
            </div>

            <!-- WAV to PDM Conversion -->
            <div class="section-card rounded-xl p-6 space-y-4">
                <h2 class="text-2xl font-bold text-indigo-300 border-b border-indigo-500/50 pb-2 mb-4">
                    3. WAV (PCM) to PDM
                </h2>
                <div class="space-y-3">
                    <label for="wavFile" class="block text-sm font-medium text-gray-300">Upload WAV File (.wav)</label>
                    <input type="file" id="wavFile" accept=".wav, audio/wav" class="w-full p-2 rounded-lg bg-gray-700 border border-gray-600 text-white focus:ring-indigo-500 focus:border-indigo-500">
                </div>
                <div class="space-y-3">
                    <label for="osr" class="block text-sm font-medium text-gray-300">Oversampling Ratio (OSR)</label>
                    <input type="number" id="osr" value="64" min="2" step="2" class="w-full p-2 rounded-lg bg-gray-700 border border-gray-600 text-white focus:ring-indigo-500 focus:border-indigo-500">
                    <p class="text-xs text-gray-400">PDM Rate = WAV Rate * OSR</p>
                </div>
                <button onclick="handleWavToPdm()" class="w-full mt-4 bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-3 px-4 rounded-lg transition-all duration-200 focus:outline-none focus:ring-4 focus:ring-indigo-500/50 shadow-md">
                    Convert & Download PDM (.bin)
                </button>
            </div>

        </div>
    </div>

    <!-- JavaScript Implementation -->
    <script>
        const statusMessage = document.getElementById('status-message');

        /**
         * Generic file downloader function.
         */
        function downloadFile(data, filename, mimeType) {
            const blob = new Blob([data], { type: mimeType });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        /**
         * Sets the application status message.
         */
        function setStatus(message, isError = false) {
            statusMessage.textContent = message;
            if (isError) {
                statusMessage.className = 'text-center text-red-400 font-medium h-6';
                console.error(message);
            } else {
                statusMessage.className = 'text-center text-green-400 font-medium h-6';
                console.log(message);
            }
        }
        
        // --- 1. PDM SIGNAL GENERATION (AND SAVE TO BINARY) ---

        /**
         * Generates analog audio samples based on the signal type.
         * @param {string} type - 'sine', 'square', or 'noise'.
         * @param {number} freq - Signal frequency.
         * @param {number} rate - Sample rate (PDM rate).
         * @param {number} duration - Duration in seconds.
         * @returns {Float32Array} Array of samples between -1.0 and 1.0.
         */
        function generateAnalogSignal(type, freq, rate, duration) {
            const numSamples = Math.floor(rate * duration);
            const samples = new Float32Array(numSamples);
            
            for (let i = 0; i < numSamples; i++) {
                const t = i / rate; // time
                const amplitude = 0.5; // Use 0.5 to avoid clipping in the SDM
                
                switch (type) {
                    case 'sine':
                        samples[i] = amplitude * Math.sin(2 * Math.PI * freq * t);
                        break;
                    case 'square':
                        // Simple square wave approximation using sine phase
                        samples[i] = Math.sign(Math.sin(2 * Math.PI * freq * t)) * amplitude;
                        break;
                    case 'noise':
                        // White Noise (between -amplitude and +amplitude)
                        samples[i] = (Math.random() * 2 - 1) * amplitude;
                        break;
                    default:
                        samples[i] = 0;
                        break;
                }
            }
            return samples;
        }

        /**
         * Converts analog PCM samples to a raw PDM bitstream using a 1st-order Sigma-Delta Modulator.
         * This logic applies to PDM Generation (1) and WAV to PDM Conversion (3).
         * @param {Float32Array} analogSamples - Input PCM samples (-1.0 to 1.0).
         * @returns {ArrayBuffer} Raw PDM bitstream packed into bytes.
         */
        function samplesToPDM(analogSamples) {
            let integrator = 0.0;
            const numSamples = analogSamples.length;
            const numBytes = Math.ceil(numSamples / 8);
            const buffer = new ArrayBuffer(numBytes);
            const view = new DataView(buffer);
            
            let byteIndex = 0;
            let bitPosition = 0;
            let currentByte = 0;

            for (let i = 0; i < numSamples; i++) {
                const input = analogSamples[i];

                // 1st-Order Sigma-Delta Modulation
                integrator += input;
                let outputBit;
                
                if (integrator >= 0) {
                    outputBit = 1;
                    integrator -= 1.0;
                } else {
                    outputBit = 0;
                    integrator += 1.0;
                }

                // Pack the bit (LSB first for simplicity, typical PDM is MSB)
                if (outputBit === 1) {
                    currentByte |= (1 << bitPosition);
                }

                bitPosition++;

                if (bitPosition >= 8) {
                    view.setUint8(byteIndex, currentByte);
                    byteIndex++;
                    currentByte = 0;
                    bitPosition = 0;
                }
            }
            
            // Write the last, partially filled byte
            if (bitPosition > 0) {
                view.setUint8(byteIndex, currentByte);
            }

            return buffer;
        }

        async function handleGeneratePDM() {
            setStatus("Generating PDM signal...");
            try {
                const type = document.getElementById('signalType').value;
                const freq = parseFloat(document.getElementById('signalFreq').value);
                const rate = parseFloat(document.getElementById('pdmRate').value);
                const duration = parseFloat(document.getElementById('duration').value);

                if (isNaN(freq) || isNaN(rate) || isNaN(duration) || rate <= 0 || duration <= 0) {
                    setStatus("Invalid input values.", true);
                    return;
                }

                const analogSamples = generateAnalogSignal(type, freq, rate, duration);
                const pdmBitstream = samplesToPDM(analogSamples);

                downloadFile(pdmBitstream, `${type}-${freq}Hz_r${rate}Hz.bin`, 'application/octet-stream');
                setStatus(`Successfully generated and downloaded PDM binary file for ${type}.`);
            } catch (error) {
                setStatus(`Error during PDM generation: ${error.message}`, true);
            }
        }


        // --- 2. PDM TO WAV CONVERSION ---

        /**
         * Decimates and filters a raw PDM bitstream into a standard PCM Float32Array.
         * This uses a Sinc1 filter (Moving Average).
         * @param {ArrayBuffer} pdmBuffer - Raw PDM bitstream data.
         * @param {number} R - Decimation factor.
         * @returns {Float32Array} PCM samples (-1.0 to 1.0).
         */
        function pdmToPcm(pdmBuffer, R) {
            const view = new DataView(pdmBuffer);
            const totalBytes = pdmBuffer.byteLength;
            const totalPDMbits = totalBytes * 8;
            
            const pcmSamples = [];
            let currentSum = 0;
            let bitCount = 0;
            let pcmSampleCounter = 0;

            // Iterate through every bit in the PDM stream
            for (let i = 0; i < totalBytes; i++) {
                const byte = view.getUint8(i);
                
                // Read 8 bits from the byte
                for (let j = 0; j < 8; j++) {
                    if (pcmSampleCounter >= totalPDMbits) break;

                    // Get the bit value (LSB first packing assumed)
                    const bit = (byte >> j) & 1; 

                    // Convert bit (0 or 1) to bipolar value (-1.0 or 1.0)
                    // The Sinc filter will integrate these bipolar values.
                    currentSum += (bit * 2.0 - 1.0); // 0 -> -1.0, 1 -> 1.0

                    bitCount++;

                    // Decimate: When we have R bits, create one PCM sample
                    if (bitCount >= R) {
                        // Normalize the accumulated sum and scale to PCM range (-1.0 to 1.0)
                        const pcmValue = currentSum / R; 
                        pcmSamples.push(pcmValue);

                        // Reset filter state
                        currentSum = 0;
                        bitCount = 0;
                    }
                    pcmSampleCounter++;
                }
            }

            return new Float32Array(pcmSamples);
        }

        /**
         * Writes a WAV file header and data chunk.
         * @param {Float32Array} pcmData - PCM samples (-1.0 to 1.0).
         * @param {number} sampleRate - Final PCM sample rate.
         * @param {number} bitDepth - Output bit depth (16 or 32).
         * @param {number} formatCode - WAV Format Code (1=PCM Int, 3=IEEE Float).
         * @returns {ArrayBuffer} The complete WAV file binary data.
         */
        function encodeWav(pcmData, sampleRate, bitDepth, formatCode) {
            const numChannels = 1;
            const bytesPerSample = bitDepth / 8;
            const numSamples = pcmData.length;
            
            // Total size of the data chunk
            const dataSize = numSamples * numChannels * bytesPerSample;
            // Total file size (36 bytes for header + dataSize)
            const fileSize = 36 + dataSize; 
            
            // Create the buffer (44 bytes for header + data size)
            const buffer = new ArrayBuffer(44 + dataSize);
            const view = new DataView(buffer);
            let offset = 0;

            // RIFF Chunk (0 - 11)
            writeString('RIFF'); // Chunk ID (0-3)
            view.setUint32(offset, fileSize, true); offset += 4; // Chunk Size (4-7)
            writeString('WAVE'); // Format (8-11)
            
            // FMT Chunk (12 - 35)
            writeString('fmt '); // Sub-chunk 1 ID (12-15)
            view.setUint32(offset, 16, true); offset += 4; // Sub-chunk 1 size (16-19) - 16 for PCM/Float
            view.setUint16(offset, formatCode, true); offset += 2; // Audio format (20-21) - 1=PCM, 3=IEEE Float
            view.setUint16(offset, numChannels, true); offset += 2; // Channels (22-23)
            view.setUint32(offset, sampleRate, true); offset += 4; // Sample Rate (24-27)
            view.setUint32(offset, sampleRate * numChannels * bytesPerSample, true); offset += 4; // Byte Rate (28-31)
            view.setUint16(offset, numChannels * bytesPerSample, true); offset += 2; // Block Align (32-33)
            view.setUint16(offset, bitDepth, true); offset += 2; // Bit Depth (34-35)

            // DATA Chunk (36 - end)
            writeString('data'); // Sub-chunk 2 ID (36-39)
            view.setUint32(offset, dataSize, true); offset += 4; // Sub-chunk 2 Size (40-43)

            // PCM Data (44 - end)
            for (let i = 0; i < numSamples; i++) {
                let sample = pcmData[i];
                // Clamp sample to the valid range [-1, 1]
                sample = Math.max(-1, Math.min(1, sample));
                
                if (formatCode === 1) { // 16-bit Signed Integer (PCM)
                    const scale = 32767; // Max value for 16-bit signed int
                    view.setInt16(offset, sample * scale, true);
                    offset += 2; // 2 bytes
                } else if (formatCode === 3) { // 32-bit IEEE Floating Point
                    view.setFloat32(offset, sample, true);
                    offset += 4; // 4 bytes
                }
            }
            
            return buffer;

            function writeString(s) {
                for (let i = 0; i < s.length; i++) {
                    view.setUint8(offset++, s.charCodeAt(i));
                }
            }
        }

        async function handlePdmToWav() {
            setStatus("Starting PDM to WAV conversion...");
            const fileInput = document.getElementById('pdmFile');
            const R = parseInt(document.getElementById('decimationFactor').value);
            const inputPdmRate = parseFloat(document.getElementById('inputPdmRate').value);
            const bitDepthInput = document.getElementById('outputBitDepth').value;
            
            if (fileInput.files.length === 0) {
                setStatus("Please select a PDM binary file.", true);
                return;
            }
            if (isNaN(R) || R < 2) {
                setStatus("Invalid Decimation Factor (R). Must be 2 or greater.", true);
                return;
            }
            if (isNaN(inputPdmRate) || inputPdmRate <= 0) {
                setStatus("Invalid PDM Rate.", true);
                return;
            }

            try {
                // Determine output format
                let bitDepth;
                let formatCode; // 1 for PCM, 3 for IEEE Float
                
                if (bitDepthInput === '32f') {
                    bitDepth = 32;
                    formatCode = 3;
                } else { // Default to 16-bit
                    bitDepth = 16;
                    formatCode = 1;
                }

                const pdmBuffer = await fileInput.files[0].arrayBuffer();
                
                const pcmSamples = pdmToPcm(pdmBuffer, R);
                const pcmRate = Math.floor(inputPdmRate / R);

                if (pcmSamples.length === 0) {
                    setStatus("No PCM samples could be generated. PDM file might be too short or invalid.", true);
                    return;
                }
                
                const wavBuffer = encodeWav(pcmSamples, pcmRate, bitDepth, formatCode);
                
                downloadFile(wavBuffer, `decoded_pdm_r${R}_${pcmRate}Hz_${bitDepth}bit.wav`, 'audio/wav');
                setStatus(`Successfully converted PDM to WAV. PCM Sample Rate: ${pcmRate} Hz, Bit Depth: ${bitDepth} (Format ${formatCode}).`);

            } catch (error) {
                setStatus(`Error during PDM to WAV conversion: ${error.message}`, true);
            }
        }


        // --- 3. WAV TO PDM CONVERSION ---

        async function handleWavToPdm() {
            setStatus("Starting WAV to PDM conversion...");
            const fileInput = document.getElementById('wavFile');
            const OSR = parseInt(document.getElementById('osr').value);

            if (fileInput.files.length === 0) {
                setStatus("Please select a WAV file.", true);
                return;
            }
            if (isNaN(OSR) || OSR < 2) {
                setStatus("Invalid Oversampling Ratio (OSR). Must be 2 or greater.", true);
                return;
            }

            try {
                // 1. Decode WAV file using Web Audio API
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const fileArrayBuffer = await fileInput.files[0].arrayBuffer();
                const audioBuffer = await audioContext.decodeAudioData(fileArrayBuffer);

                const sourceRate = audioBuffer.sampleRate;
                const pdmRate = sourceRate * OSR;
                const sourceData = audioBuffer.getChannelData(0); // Use the first channel

                // 2. Resample the PCM data to the PDM rate
                setStatus(`Resampling PCM (${sourceRate}Hz) to PDM rate (${pdmRate}Hz)...`);
                const resampleRatio = pdmRate / sourceRate;
                const newLength = Math.ceil(sourceData.length * resampleRatio);
                const resampledData = new Float32Array(newLength);

                for (let i = 0; i < newLength; i++) {
                    // Linear interpolation for resampling
                    const oldIndex = i / resampleRatio;
                    const floorIndex = Math.floor(oldIndex);
                    const ceilIndex = Math.min(sourceData.length - 1, floorIndex + 1);
                    const frac = oldIndex - floorIndex;

                    const sampleA = sourceData[floorIndex];
                    const sampleB = sourceData[ceilIndex];

                    resampledData[i] = sampleA + (sampleB - sampleA) * frac;
                }

                // 3. Convert resampled PCM to PDM bitstream
                setStatus("Applying Sigma-Delta Modulation...");
                // Note: The input samples must be within -1.0 to 1.0, which AudioBuffer data is.
                const pdmBitstream = samplesToPDM(resampledData);

                downloadFile(pdmBitstream, `encoded_wav_osr${OSR}_${pdmRate}Hz.bin`, 'application/octet-stream');
                setStatus(`Successfully converted WAV to PDM binary. PDM Sample Rate: ${pdmRate} Hz.`);

            } catch (error) {
                setStatus(`Error during WAV to PDM conversion: ${error.message}`, true);
            }
        }
    </script>
</body>
</html>
